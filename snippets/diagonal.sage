from auxiliary import *

"""We compute the class of the diagonal inside the Chow ring A^*(X x X) where X is the moduli space of the 3-Kronecker quiver with d = [2,3] and theta = [3,-2]."""

"""t1,t2 are the Chern roots of the bundle p_1^*U_1 and s1,s2,s3 are the Chern roots of the bundle p_1^*U_2 while tt1,tt2 and ss1,ss2,ss3 are the Chern roots of the bundles p_2^*U_1 and p_2^*U_2. They generate the Chow ring of the quotient stack [R/T] x [R/T]."""
R.<t1,t2,s1,s2,s3,tt1,tt2,ss1,ss2,ss3> = PolynomialRing(QQ)
Delta = (t2-t1)*(s2-s1)*(s3-s1)*(s3-s2)
DDelta = (tt2-tt1)*(ss2-ss1)*(ss3-ss1)*(ss3-ss2)
t = [t1,t2]
s = [s1,s2,s3]
tt = [tt1,tt2]
ss = [ss1,ss2,ss3]

"""We give names to the elementary symmetric functions in the t's, the s's, the tt's and the ss's but they live in the ring A^*([R/T] x [R/T]). We need to change the ring to obtain the subring which is generated by them."""
e1, e2 = t1+t2, t1*t2
d1, d2, d3 = s1+s2+s3, s1*s2+s1*s3+s2*s3, s1*s2*s3
ee1, ee2 = tt1+tt2, tt1*tt2
dd1, dd2, dd3 = ss1+ss2+ss3, ss1*ss2+ss1*ss3+ss2*ss3, ss1*ss2*ss3

"""The Chow ring of [R/G] x [R/G] is the subring of A^*([R/T] x [R/G]) generated by the elementary symmetric functions."""
A.<x1,x2,y1,y2,y3,xx1,xx2,yy1,yy2,yy3> = PolynomialRing(QQ, order=TermOrder('wdegrevlex', (1,2,1,2,3,1,2,1,2,3)))

"""Now we define the homomorphism A --> R which sends x_r to e_r, y_s to d_s, xx_r to ee_r and yy_s to dd_s."""
inclusion = A.hom([e1,e2,d1,d2,d3,ee1,ee2,dd1,dd2,dd3],R)

"""A^*([R/T] x [R/T]) is free as an A^*([R/G] x [R/G])-module. A basis is given by products of all Demazure operators applied to the following elements X and XX."""
X = t1*s1^2*s2
XX = tt1*ss1^2*ss2

"""W is the Weyl group of T inside G."""
S2 = Permutations(2).list()
S3 = Permutations(3).list()
W = cartesian_product([S2,S3])
w0 = (Permutation([2,1]), Permutation([3,2,1]))

"""Now to the 'forbidden' polynomials. They live in A^*([R/T]).
They should be defined as a function of the forbidden subdimension vector
in the general implementation. The general formula is
prod_{a in Q_1} prod_{r=1}^{d'_{s(a)}} prod_{s=d'_{t(a)}+1}^{d_{t(a)}} (t_{t(a),s} - t_{s(a),r}).
The forbidden subdimension vectors are (1,1) and (2,2)."""
f11 = (s2-t1)^3*(s3-t1)^3
f22 = (s3-t1)^3*(s3-t2)^3
ff11 = (ss2-tt1)^3*(ss3-tt1)^3
ff22 = (ss3-tt1)^3*(ss3-tt2)^3

def Demazure_operator(w,ww,f):
    """Iterated application of the divided difference operators"""

    reducedt = w[0].reduced_word()
    reducedt.reverse()
    reduceds = w[1].reduced_word()
    reduceds.reverse()
    for i in reducedt:
        f = divided_difference(i,f,[t1,t2])
    for j in reduceds:
        f = divided_difference(j,f,[s1,s2,s3])
    # Now same for tt's and ss's with ww
    reducedtt = ww[0].reduced_word()
    reducedtt.reverse()
    reducedss = ww[1].reduced_word()
    reducedss.reverse()
    for i in reducedtt:
        f = divided_difference(i,f,[tt1,tt2])
    for j in reducedss:
        f = divided_difference(j,f,[ss1,ss2,ss3])

    return f

def Schubert(w,ww):
    """The Schubert polynomial S_{w,ww} is in this context defined as S_{w,ww} = d_{w_0w^{-1}}X*d_{w0ww^{-1}}XX, where d is the Demazure operator and w_0 is the longest Weyl group element."""

    u = (w0[0]*w[0].inverse(), w0[1]*w[1].inverse())
    uu = (w0[0]*ww[0].inverse(), w0[1]*ww[1].inverse())
    return Demazure_operator(u,uu,X*XX)

def left_Weyl_group_action_on_polynomial(w,ww,f):
    """Computes the left action of Weyl group element (w,ww) in W x W on f(t_1,t_2,s_1,s_2,s_3,tt_1,tt_2,ss_1,ss_2,ss_3)"""

    # First let w act on {t_1,t_2} and {s_1,s_2,s_3} from the left
    # Same for ww on {tt_1,tt_2} and {ss_1,ss_2,ss_3}
    wAppliedTot = left_permutation_action_on_list(w[0],t)
    wAppliedTos = left_permutation_action_on_list(w[1],s)
    wwAppliedTott = left_permutation_action_on_list(ww[0],tt)
    wwAppliedToss = left_permutation_action_on_list(ww[1],ss)
    # Make dicts {t_i:t_w(i)} and similarly for s
    d = dict(zip(t,wAppliedTot))
    d.update(dict(zip(s,wAppliedTos)))
    d.update(dict(zip(tt,wwAppliedTott)))
    d.update(dict(zip(ss,wwAppliedToss)))

    # substitute t_i = t_w(i), s_j = s_w(j) and so on in f
    return f.subs(d)

def sign(w):
    """Sign of Weyl group element w"""
    return Permutation(w[0]).sign()*Permutation(w[1]).sign()


def antisymmetrization(f):
    """Computes sum_{w in W} sign(w)*(fw)"""
    return sum(list(map(lambda w, ww: sign(w)*sign(ww)*left_Weyl_group_action_on_polynomial(w,ww,f), W, W)))

def symmetrization(f):
    return antisymmetrization(f)/(Delta*DDelta)

def schubert_basis():
    """Consists of all Schubert polynomials."""
    return list(map(Schubert,W,W))

def tautological():

    def tautological_upstairs():
        """Auxiliary method. These are the tautological relations already, but they
        live in the wrong ring."""
        indexSet = cartesian_product([schubert_basis(),[f11,f22]])
        return list(map(lambda  pairOfPolys: symmetrization(pairOfPolys[0]*pairOfPolys[1]), indexSet))

    return list(map(inclusion.inverse_image,tautological_upstairs()))
