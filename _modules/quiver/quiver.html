<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>quiver.quiver - QuiverTools v0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">QuiverTools v0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">QuiverTools v0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for quiver.quiver</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">sage.arith.misc</span> <span class="kn">import</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">sage.categories.cartesian_product</span> <span class="kn">import</span> <span class="n">cartesian_product</span>
<span class="kn">from</span> <span class="nn">sage.graphs.digraph</span> <span class="kn">import</span> <span class="n">DiGraph</span>
<span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="kn">from</span> <span class="nn">sage.matrix.special</span> <span class="kn">import</span> <span class="n">zero_matrix</span>
<span class="kn">from</span> <span class="nn">sage.misc.cachefunc</span> <span class="kn">import</span> <span class="n">cached_method</span>
<span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>
<span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">Element</span>


<div class="viewcode-block" id="Quiver">
<a class="viewcode-back" href="../../index.html#quiver.Quiver">[docs]</a>
<span class="k">class</span> <span class="nc">Quiver</span><span class="p">(</span><span class="n">Element</span><span class="p">):</span>
<div class="viewcode-block" id="Quiver.__init__">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor for a quiver.</span>

<span class="sd">        This takes a directed graph as input. If it is not a DiGraph instance,</span>
<span class="sd">        it is interpreted it as an adjacency matrix.</span>
<span class="sd">        For other constructions, see</span>

<span class="sd">        - :meth:`Quiver.from_digraph`</span>
<span class="sd">        - :meth:`Quiver.from_matrix`</span>
<span class="sd">        - :meth:`Quiver.from_string`</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``G`` -- directed graph</span>

<span class="sd">        - ``name`` -- optional name for the quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = Quiver([[0, 3], [0, 0]]); Q</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>

<span class="sd">        A Dynkin quiver of type A_3::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;1-2-3&quot;); Q.adjacency_matrix()</span>
<span class="sd">            [0 1 0]</span>
<span class="sd">            [0 0 1]</span>
<span class="sd">            [0 0 0]</span>

<span class="sd">        A triangle-shaped quiver::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;1-2-3, 1-3&quot;); Q.adjacency_matrix()</span>
<span class="sd">            [0 1 1]</span>
<span class="sd">            [0 0 1]</span>
<span class="sd">            [0 0 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">DiGraph</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__G</span> <span class="o">=</span> <span class="n">G</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

        <span class="c1"># if name is None this doesn&#39;t do anything</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># for caching purposes: order along the specified order of vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__G</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></div>


<div class="viewcode-block" id="Quiver.from_digraph">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.from_digraph">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_digraph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Construct a quiver from a DiGraph object.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``G`` -- directed graph</span>

<span class="sd">        - ``name`` -- optional name for the quiver</span>

<span class="sd">        OUTPUT: the quiver.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: M = [[0, 3], [0, 0]]</span>
<span class="sd">            sage: Quiver.from_digraph(DiGraph(matrix(M))) == Quiver.from_matrix(M)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.from_matrix">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.from_matrix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_matrix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Construct a quiver from its adjacency matrix.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``M`` -- adjacency matrix of the quiver</span>

<span class="sd">        - ``name`` -- optional name for the quiver</span>

<span class="sd">        OUTPUT: the quiver.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = Quiver.from_matrix([[0, 3], [0, 0]]); Q.adjacency_matrix()</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [0 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)),</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.from_string">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.from_string">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Construct a quiver from a comma-separated list of chains like ``i-j-k-...``</span>

<span class="sd">        You specify an arrow from ``i`` to ``j`` by writing ``i-j``.</span>
<span class="sd">        Multiple arrows are specified by repeating the hyphen, so that ``1--2`` is the</span>
<span class="sd">        Kronecker quiver. If you write ``i-j-k`` then you have 1 arrow from ``i`` to</span>
<span class="sd">        ``j``and one from ``j`` to ``k``. The full quiver is specified by concatenating</span>
<span class="sd">        (multiple) arrows by commas.</span>

<span class="sd">        The values for a vertex can be anything, and the chosen names will be used for</span>
<span class="sd">        the vertices in the underlying graph. Labels are cast to an integer, if</span>
<span class="sd">        possible, and otherwise to strings.</span>

<span class="sd">        OUTPUT: the quiver</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``Q`` -- a string of the format described above giving a quiver</span>

<span class="sd">        - ``forget_labels`` -- (default: True): whether to use labels for vertices or</span>
<span class="sd">          to number them ``0,...,n-1``</span>

<span class="sd">        - ``name`` -- optional name for the quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver defined in two different ways::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Quiver.from_matrix([[0, 3], [0, 0]]) == Quiver.from_string(&quot;a---b&quot;)</span>
<span class="sd">            True</span>

<span class="sd">        A more complicated example::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a--b-3,a---3,3-a&quot;)</span>
<span class="sd">            sage: Q.adjacency_matrix()</span>
<span class="sd">            [0 2 3]</span>
<span class="sd">            [0 0 1]</span>
<span class="sd">            [1 0 0]</span>
<span class="sd">            sage: Q.vertices()</span>
<span class="sd">            [0, 1, 2]</span>

<span class="sd">        The actual labeling we use doesn&#39;t matter for the isomorphism type of the</span>
<span class="sd">        quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Quiver.from_matrix([[0, 3], [0, 0]]) == Quiver.from_string(&quot;12---b&quot;)</span>
<span class="sd">            True</span>

<span class="sd">        However, it does influence the labels of the vertex if we choose so::</span>

<span class="sd">            sage: Quiver.from_string(&quot;12---b&quot;, forget_labels=False).vertices()</span>
<span class="sd">            [12, &#39;b&#39;]</span>
<span class="sd">            sage: Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False).vertices()</span>
<span class="sd">            [&#39;foo&#39;, &#39;bar&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove all whitespace from the string</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

        <span class="c1"># determine the vertices used in the string, preserving the order</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span>
                <span class="n">vertex</span>
                <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vertex</span>  <span class="c1"># this filters out &quot;&quot; from chained hyphens</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># adjacency matrix to be built</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">zero_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
            <span class="n">pieces</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>

            <span class="n">source</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="c1"># if the string is empty we increase the number of arrows counter</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">piece</span><span class="p">:</span>
                    <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># if the string is non-empty we treat it as a label</span>
                <span class="c1"># this means we add the appropriate number of arrows</span>
                <span class="c1"># and make the target the source to start the process again</span>
                <span class="k">if</span> <span class="n">piece</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
                    <span class="n">M</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">]</span> <span class="o">+=</span> <span class="n">number</span>

                    <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c1"># attempt to cast vertex labels to integers, otherwise to strings</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">forget_labels</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>
            <span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">perm</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for the quiver</span>

<span class="sd">        If a name is set, use that, if not, just give information on number of vertices</span>
<span class="sd">        and arrows.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = Quiver.from_string(&quot;1---2&quot;); Q</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>
<span class="sd">            sage: Q.rename(&quot;3-Kronecker quiver&quot;); Q</span>
<span class="sd">            3-Kronecker quiver</span>

<span class="sd">        Renaming and resetting the name::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;1---2&quot;)</span>
<span class="sd">            sage: Q.get_custom_name()</span>

<span class="sd">            sage: Q.rename(&quot;3-Kronecker quiver&quot;)</span>
<span class="sd">            sage: Q.get_custom_name()</span>
<span class="sd">            &#39;3-Kronecker quiver&#39;</span>
<span class="sd">            sage: Q.reset_name()</span>
<span class="sd">            sage: Q.get_custom_name()</span>

<span class="sd">            sage: Q</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;a quiver with </span><span class="si">{}</span><span class="s2"> vertices and </span><span class="si">{}</span><span class="s2"> arrows&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">nrows</span><span class="p">(),</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()))</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Quiver.__str__">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detailed description of the quiver</span>

<span class="sd">        Everything you get from :meth:`Quiver.repr()` together with the adjacency</span>
<span class="sd">        matrix.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = Quiver.from_string(&quot;1---2&quot;); print(Q)</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [0 0]</span>
<span class="sd">            sage: Q.rename(&quot;3-Kronecker quiver&quot;); print(Q)</span>
<span class="sd">            3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [0 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="se">\n</span><span class="s2">adjacency matrix:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repr</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">())</span></div>


<div class="viewcode-block" id="Quiver.repr">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.repr">[docs]</a>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Basic description of the quiver</span>

<span class="sd">        To override the output, one uses :meth:`Quiver.rename` from the `Element`</span>
<span class="sd">        class. The output of :meth:`Quiver.repr` is that of</span>
<span class="sd">        :meth:`Quiver.get_custom_name` if it is set, else it is the default specifying</span>
<span class="sd">        the number of vertices and arrows.</span>

<span class="sd">        OUTPUT: a basic description of the quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = Quiver.from_string(&quot;1---2&quot;); Q</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>
<span class="sd">            sage: Q.rename(&quot;3-Kronecker quiver&quot;); Q</span>
<span class="sd">            3-Kronecker quiver</span>

<span class="sd">        Renaming and resetting the name::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;1---2&quot;)</span>
<span class="sd">            sage: Q.get_custom_name()</span>

<span class="sd">            sage: Q.rename(&quot;3-Kronecker quiver&quot;)</span>
<span class="sd">            sage: Q.get_custom_name()</span>
<span class="sd">            &#39;3-Kronecker quiver&#39;</span>
<span class="sd">            sage: Q.reset_name()</span>
<span class="sd">            sage: Q.get_custom_name()</span>

<span class="sd">            sage: Q</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span></div>


<div class="viewcode-block" id="Quiver.str">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.str">[docs]</a>
    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Full description of the quiver</span>

<span class="sd">        This combines the output of :meth:`Quiver.repr` with the adjacency matrix.</span>

<span class="sd">        OUTPUT: a complete description of the quiver</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = Quiver.from_string(&quot;1---2&quot;); print(Q)</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [0 0]</span>
<span class="sd">            sage: Q.rename(&quot;3-Kronecker quiver&quot;); print(Q)</span>
<span class="sd">            3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [0 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>


<div class="viewcode-block" id="Quiver.__eq__">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.__eq__">[docs]</a>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks for equality of quivers.</span>

<span class="sd">        Equality here refers to equality of adjacency matrices,</span>
<span class="sd">        but disregarding the name of the quiver.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``other`` -- Quiver; the quiver to compare against</span>

<span class="sd">        OUTPUT: whether the adjacency matrices are the same</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 2-Kronecker quiver and the generalized Kronecker quiver are the same::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: KroneckerQuiver() == GeneralizedKroneckerQuiver(2)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_is_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether ``x`` is an element of :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        If the quiver doesn&#39;t use vertex labels we check that it has the right length.</span>
<span class="sd">        If the quiver uses vertex labels, we check that ``x`` is a dict with the right</span>
<span class="sd">        set of keys.</span>

<span class="sd">        We actually do not care whether the values are in :math:`\mathbb{Z}`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- vector</span>

<span class="sd">        OUTPUT: whether ``x`` can be used as a dimension vector for the quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some basic examples::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q._is_vector([2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_vector([0, 0])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_vector([-2, -2])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_vector([1, 2, 3])</span>
<span class="sd">            False</span>

<span class="sd">        We allow non-integral values, because this can be useful for stability::</span>

<span class="sd">            sage: Q._is_vector([1/2, 3])</span>
<span class="sd">            True</span>

<span class="sd">        An example with vertex labels::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q._is_vector({&quot;foo&quot; : 0, &quot;bar&quot; : 0})</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_vector({&quot;bar&quot; : 0, &quot;foo&quot; : 0})</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_vector({&quot;baz&quot; : 0, &quot;ofo&quot; : 0})</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_is_dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether ``d`` is a dimension vector of the quiver</span>

<span class="sd">        If the quiver doesn&#39;t use vertex labels we check that it has the right length</span>
<span class="sd">        and has positive entries.</span>
<span class="sd">        If the quiver uses vertex labels, we check that ``d`` is a dict with the right</span>
<span class="sd">        set of keys and positive entries.</span>

<span class="sd">        We only check for non-negativity, not for integrality.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` -- dimension vector</span>

<span class="sd">        OUTPUT: whether ``d`` can be used as a dimension vector for the quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some basic examples::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q._is_dimension_vector([2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_dimension_vector([0, 0])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_dimension_vector([-2, -2])</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q._is_dimension_vector([1, 2, 3])</span>
<span class="sd">            False</span>

<span class="sd">        An example with vertex labels::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q._is_dimension_vector({&quot;foo&quot; : 2, &quot;bar&quot; : 3})</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q._is_dimension_vector({&quot;bar&quot; : 0, &quot;foo&quot; : -1})</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q._is_dimension_vector({&quot;baz&quot; : 0, &quot;ofo&quot; : 0})</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_vector</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">di</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">di</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_coerce_dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coerces ``d`` to be a dimension vector of the quiver</span>

<span class="sd">        The input ``d`` must be a data structure that is indexed</span>
<span class="sd">        by the vertices of the quiver, so most likely a dict, list, or vector.</span>
<span class="sd">        It is coerced to a vector, see :meth:`Quiver._coerce_vector`.</span>

<span class="sd">        As a consistency check we verify that all entries are non-negative,</span>
<span class="sd">        raising a `ValueError` if it isn&#39;t the case.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: a candidate dimension vector</span>

<span class="sd">        OUTPUT: either a dict or vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q._coerce_dimension_vector([1, 2])</span>
<span class="sd">            (1, 2)</span>
<span class="sd">            sage: Q._coerce_dimension_vector([1, 2, 3, 4])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: The input is not an element of :math:`\mathbb{Z}Q_0`.</span>
<span class="sd">            sage: Q._coerce_dimension_vector([1, -3])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: The input is not a dimension vector of the quiver.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">di</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input is not a dimension vector of the quiver.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_coerce_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coerces ``x`` to be a vector in :math:`\mathbb{Z}Q_0`.</span>

<span class="sd">        The input ``x`` must be a data structure that is indexed by</span>
<span class="sd">        the vertices of the quiver,</span>
<span class="sd">        so most likely a dict, list, tuple, or vector.</span>

<span class="sd">        It raises a `ValueError` if it is not a data structure of length the number</span>
<span class="sd">        of vertices in the quiver.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x``: a list, tuple, or dict of integers</span>

<span class="sd">        OUTPUT: a Sage vector if ``x`` is an element of :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q._coerce_vector([-1, 2])</span>
<span class="sd">            (-1, 2)</span>
<span class="sd">            sage: Q._coerce_vector([1, 2, 3, 4])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: The input is not an element of :math:`\mathbb{Z}Q_0`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;The input is not an element of :math:`\mathbb</span><span class="si">{Z}</span><span class="s2">Q_0`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()])</span>

        <span class="c1"># so that it can be used for hashing</span>
        <span class="n">x</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">x</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic graph-theoretic properties of the quiver</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.adjacency_matrix">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.adjacency_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the adjacency matrix of the quiver.</span>

<span class="sd">        OUTPUT: The square matrix ``M`` whose entry ``M[i,j]`` is the number of arrows</span>
<span class="sd">        from the vertex ``i`` to the vertex ``j``</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">        The adjacency matrix of a quiver construct from an adjacency matrix::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: M = matrix([[0, 3], [0, 0]])</span>
<span class="sd">            sage: M == Quiver(M).adjacency_matrix()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__M</span></div>


<div class="viewcode-block" id="Quiver.graph">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.graph">[docs]</a>
    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the underlying graph of the quiver</span>

<span class="sd">        OUTPUT: the underlying quiver as a DiGraph object</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The underlying graph of the quiver from a directed graph is that graph::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: G = DiGraph(matrix([[0, 3], [0, 0]]))</span>
<span class="sd">            sage: G == Quiver.from_digraph(G).graph()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__G</span></div>


<div class="viewcode-block" id="Quiver.vertices">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vertices of the quiver</span>

<span class="sd">        If the quiver is created from a DiGraph or string, the vertices are labelled</span>
<span class="sd">        using the data in the DiGraph or string, as explained in</span>
<span class="sd">        :meth:`Quiver.from_digraph` or :meth:`Quiver.from_string`.</span>
<span class="sd">        If the quiver is created from a matrix, the vertices are labelled from `0`</span>
<span class="sd">        to `n-1`, where `n` is the number of rows or columns in the matrix.</span>

<span class="sd">        OUTPUT: the vertices in the underlying graph</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Usually the vertices will be just integers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Quiver([[0, 3], [0, 0]]).vertices()</span>
<span class="sd">            [0, 1]</span>

<span class="sd">        We can have non-trivial labels for a quiver::</span>

<span class="sd">            sage: Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False).vertices()</span>
<span class="sd">            [&#39;foo&#39;, &#39;bar&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.number_of_vertices">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.number_of_vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">number_of_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of vertices</span>

<span class="sd">        OUTPUT: the number of vertices</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        There are 3 vertices in a 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: ThreeVertexQuiver(1, 2, 4).number_of_vertices()</span>
<span class="sd">            3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">order</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">__has_vertex_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check whether vertex labels are used</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        With vertex labels::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(2)</span>
<span class="sd">            sage: Q._Quiver__has_vertex_labels()</span>
<span class="sd">            False</span>

<span class="sd">        With vertex labels::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q._Quiver__has_vertex_labels()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()))</span>

<div class="viewcode-block" id="Quiver.number_of_arrows">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.number_of_arrows">[docs]</a>
    <span class="k">def</span> <span class="nf">number_of_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the number of arrows</span>

<span class="sd">        OUTPUT: the number of arrows</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        There are 7 arrows in this 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: ThreeVertexQuiver(1, 2, 4).number_of_arrows()</span>
<span class="sd">            7</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">()</span></div>


<div class="viewcode-block" id="Quiver.is_acyclic">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_acyclic">[docs]</a>
    <span class="k">def</span> <span class="nf">is_acyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns whether the quiver is acyclic.</span>

<span class="sd">        OUTPUT: True if the quiver is acyclic, False otherwise.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An acyclic graph::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: KroneckerQuiver(3).is_acyclic()</span>
<span class="sd">            True</span>

<span class="sd">        A non-acyclic graph::</span>

<span class="sd">            sage: GeneralizedJordanQuiver(5).is_acyclic()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_directed_acyclic</span><span class="p">()</span></div>


<div class="viewcode-block" id="Quiver.is_connected">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_connected">[docs]</a>
    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns whether the underlying graph of the quiver is connected or not.</span>

<span class="sd">        OUTPUT: True if the quiver is connected, False otherwise.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The n-Kronecker quivers are connected::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: KroneckerQuiver(4).is_connected()</span>
<span class="sd">            True</span>

<span class="sd">        The loop quivers are connected::</span>

<span class="sd">            sage: GeneralizedJordanQuiver(3).is_connected()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Some graph-theoretic properties of the quiver</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.in_degree">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.in_degree">[docs]</a>
    <span class="k">def</span> <span class="nf">in_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the in-degree of a vertex.</span>

<span class="sd">        The in-degree of ``i`` is the number of incoming arrows at ``i``.</span>

<span class="sd">        The parameter ``i`` must be an element of the vertices of the underlying graph.</span>
<span class="sd">        If constructed from a matrix or string, ``i`` can go from `0` to</span>
<span class="sd">        `n-1` where `n` is the number of vertices in the graph.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``i`` -- a vertex of the underlying graph</span>

<span class="sd">        OUTPUT: The in-degree of the vertex ``i``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        In the 3-Kronecker quiver the in-degree is either 0 or 3::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.in_degree(0)</span>
<span class="sd">            0</span>
<span class="sd">            sage: Q.in_degree(1)</span>
<span class="sd">            3</span>

<span class="sd">        If we specified a non-standard labeling on the vertices we must use it::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a---b&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.in_degree(&quot;a&quot;)</span>
<span class="sd">            0</span>
<span class="sd">            sage: Q.in_degree(&quot;b&quot;)</span>
<span class="sd">            3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.out_degree">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.out_degree">[docs]</a>
    <span class="k">def</span> <span class="nf">out_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the out-degree of a vertex.</span>

<span class="sd">        The parameter ``i`` must be an element of the vertices of the underlying graph.</span>
<span class="sd">        If constructed from a matrix or string, ``i`` can go from `0` to</span>
<span class="sd">        `n-1` where `n` is the number of vertices in the graph.</span>

<span class="sd">        The out-degree of ``i`` is the number of outgoing arrows at ``i``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``i`` -- a vertex of the underlying graph</span>

<span class="sd">        OUTPUT: The out-degree of the vertex ``i``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        In the 3-Kronecker quiver the out-degree is either 3 or 0::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.out_degree(0)</span>
<span class="sd">            3</span>
<span class="sd">            sage: Q.out_degree(1)</span>
<span class="sd">            0</span>

<span class="sd">        If we specified a non-standard labeling on the vertices we must use it::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a---b&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.out_degree(&quot;a&quot;)</span>
<span class="sd">            3</span>
<span class="sd">            sage: Q.out_degree(&quot;b&quot;)</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.is_source">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_source">[docs]</a>
    <span class="k">def</span> <span class="nf">is_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if ``i`` is a source of the quiver</span>

<span class="sd">        The vertex ``i`` is a source if there are no incoming arrows at ``i``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``i`` -- a vertex of the quiver</span>

<span class="sd">        OUTPUT: whether ``i`` is a source of the quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver has one source::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_source(0)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_source(1)</span>
<span class="sd">            False</span>

<span class="sd">        If we specified a non-standard labeling on the vertices we must use it::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a---b&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.is_source(&quot;a&quot;)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_source(&quot;b&quot;)</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Quiver.is_sink">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_sink">[docs]</a>
    <span class="k">def</span> <span class="nf">is_sink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if ``i`` is a sink of the quiver</span>

<span class="sd">        The vertex ``i`` is a sink if there are no outgoing arrows out of ``i``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``i`` -- a vertex of the quiver</span>

<span class="sd">        OUTPUT: whether ``i`` is a sink of the quiver</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        The 3-Kronecker quiver has one sink::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_sink(0)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.is_sink(1)</span>
<span class="sd">            True</span>

<span class="sd">        If we specified a non-standard labeling on the vertices we must use it::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a---b&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.is_sink(&quot;a&quot;)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.is_sink(&quot;b&quot;)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Quiver.sources">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.sources">[docs]</a>
    <span class="k">def</span> <span class="nf">sources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the vertices which are sources in the quiver</span>

<span class="sd">        OUTPUT: the list of vertices without incoming edges</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver has one source::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: GeneralizedKroneckerQuiver(3).sources()</span>
<span class="sd">            [0]</span>

<span class="sd">        It is possible that a quiver has no sources::</span>

<span class="sd">            sage: JordanQuiver().sources()</span>
<span class="sd">            []</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_source</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span></div>


<div class="viewcode-block" id="Quiver.sinks">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.sinks">[docs]</a>
    <span class="k">def</span> <span class="nf">sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the vertices which are sinks in the quiver</span>

<span class="sd">        OUTPUT: the list of vertices without incoming edges</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver has one source::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: GeneralizedKroneckerQuiver(3).sources()</span>
<span class="sd">            [0]</span>

<span class="sd">        It is possible that a quiver has no sinks::</span>

<span class="sd">            sage: JordanQuiver().sinks()</span>
<span class="sd">            []</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sink</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()))</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic representation-theoretical properties of the quiver</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.euler_matrix">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.euler_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">euler_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the Euler matrix of the quiver</span>

<span class="sd">        This is the matrix representing the Euler form, defined by</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \langle\mathbf{d},\mathbf{e}\rangle=</span>
<span class="sd">            \sum_{i\in Q_0}d_i e_i-\sum_{\alpha\in Q_1}d_{s(\alpha)}e_{t(\alpha)}</span>

<span class="sd">        In the basis given by the vertices, it can be written as the difference</span>
<span class="sd">        of the identity matrix and the adjacency matrix.</span>

<span class="sd">        OUTPUT: the Euler matrix of the quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker 3-quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: GeneralizedKroneckerQuiver(3).euler_matrix()</span>
<span class="sd">            [ 1 -3]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        It uses the basis of the vertices, so it agrees with this alternative</span>
<span class="sd">        definition::</span>

<span class="sd">            sage: Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False).euler_matrix()</span>
<span class="sd">            [ 1 -3]</span>
<span class="sd">            [ 0  1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span></div>


<div class="viewcode-block" id="Quiver.euler_form">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.euler_form">[docs]</a>
    <span class="k">def</span> <span class="nf">euler_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The value :math:`\langle x,y\rangle` of the Euler form</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        - ``y`` -- an element of :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        OUTPUT: the value of the Euler form, i.e., ``x * self.euler_matrix() * y``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An example using the Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.euler_form([1, 3], [2, -2])</span>
<span class="sd">            2</span>

<span class="sd">        It uses the basis of the vertices, so we specify the entries of elements of</span>
<span class="sd">        :math:`\mathbb{Z}Q_0` in this order, thus the same example as before::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.euler_form([1, 3], [2, -2])</span>
<span class="sd">            2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_matrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">y</span></div>


<div class="viewcode-block" id="Quiver.cartan_matrix">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.cartan_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">cartan_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the Cartan matrix of the quiver</span>

<span class="sd">        This is the matrix representing the symmetrization of the Euler form,</span>
<span class="sd">        see :meth:`Quiver.euler_matrix`</span>

<span class="sd">        OUTPUT: the Cartan matrix of the quiver</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">        The Kronecker 3-quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: GeneralizedKroneckerQuiver(3).cartan_matrix()</span>
<span class="sd">            [ 2 -3]</span>
<span class="sd">            [-3  2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_matrix</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="Quiver.symmetrized_euler_form">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.symmetrized_euler_form">[docs]</a>
    <span class="k">def</span> <span class="nf">symmetrized_euler_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The value :math:`(x,y)` of the Euler form</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        - ``y`` -- an element of :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        OUTPUT: the value of the symmetrized Euler form applied to ``x`` and ``y``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An example using the Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.symmetrized_euler_form([1, 3], [2, -2])</span>
<span class="sd">            -20</span>

<span class="sd">        It uses the basis of the vertices, so we specify the entries of elements of</span>
<span class="sd">        :math:`\mathbb{Z}Q_0` in this order, thus the same example as before::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.symmetrized_euler_form([1, 3], [2, -2])</span>
<span class="sd">            -20</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.tits_form">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.tits_form">[docs]</a>
    <span class="k">def</span> <span class="nf">tits_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The value of the Tits quadratic form of the quiver at ``x``</span>

<span class="sd">        This is really just the value :math:`\langle x,x\rangle` of the Euler form,</span>
<span class="sd">        or half of the value :math:`(x,x)` of the symmetrized Euler form.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x`` -- an element of :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        OUTPUT: the value of the Tits form applied to ``x``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An example using the Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.tits_form([2, 3])</span>
<span class="sd">            -5</span>

<span class="sd">        It uses the basis of the vertices, so we specify the entries of elements of</span>
<span class="sd">        :math:`\mathbb{Z}Q_0` in this order, thus the same example as before::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.tits_form([2, 3])</span>
<span class="sd">            -5</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructing new quivers out of old</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.opposite_quiver">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.opposite_quiver">[docs]</a>
    <span class="k">def</span> <span class="nf">opposite_quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the opposite quiver</span>

<span class="sd">        The opposite quiver is the quiver with all arrows reversed.</span>
<span class="sd">        Its adjacency matrix is given by the transpose of the adjacency matrix.</span>

<span class="sd">        OUTPUT: the opposite quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The opposite of the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: print(GeneralizedKroneckerQuiver(3).opposite_quiver())</span>
<span class="sd">            opposite of 3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 0]</span>
<span class="sd">            [3 0]</span>

<span class="sd">        It preserves the labelling of the vertices::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Qopp = Q.opposite_quiver()</span>
<span class="sd">            sage: Qopp.vertices()</span>
<span class="sd">            [&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="sd">            sage: Qopp.adjacency_matrix()</span>
<span class="sd">            [0 0]</span>
<span class="sd">            [3 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;opposite of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Quiver</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">reverse</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.doubled_quiver">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.doubled_quiver">[docs]</a>
    <span class="k">def</span> <span class="nf">doubled_quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the doubled quiver</span>

<span class="sd">        The double of a quiver is the quiver where for each arrow</span>
<span class="sd">        we add an arrow in the opposite direction.</span>

<span class="sd">        Its adjacency matrix is the sum of the adjacency matrix</span>
<span class="sd">        of the original quiver and its transpose.</span>

<span class="sd">        OUTPUT: the doubled quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The double of the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: print(GeneralizedKroneckerQuiver(3).doubled_quiver())</span>
<span class="sd">            double of 3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [3 0]</span>

<span class="sd">        It preserves the labelling of the vertices::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Qbar = Q.doubled_quiver()</span>
<span class="sd">            sage: Qbar.vertices()</span>
<span class="sd">            [&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="sd">            sage: Qbar.adjacency_matrix()</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [3 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">())</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opposite_quiver</span><span class="p">()</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;double of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Quiver</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.framed_quiver">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.framed_quiver">[docs]</a>
    <span class="k">def</span> <span class="nf">framed_quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">framing</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span><span class="s2">&quot;-oo&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the framed quiver with framing vector ``framing``</span>

<span class="sd">        The optional parameter ``vertex`` determines the name of the framing vertex,</span>
<span class="sd">        which defaults to `-oo`.</span>

<span class="sd">        The framed quiver has one additional vertex, and `f_i` many arrows from</span>
<span class="sd">        the framing vertex to `i`, for every `i\in Q_0`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``framing`` -- list of non-negative integers saying how many arrows from the</span>
<span class="sd">          framed vertex to ``i``</span>

<span class="sd">        - ``vertex`` (default: &quot;-oo&quot;) -- name of the framing vertex</span>

<span class="sd">        OUTPUT: the framed quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Framing the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3).framed_quiver([1, 0])</span>
<span class="sd">            sage: print(Q)</span>
<span class="sd">            framing of 3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 1 0]</span>
<span class="sd">            [0 0 3]</span>
<span class="sd">            [0 0 0]</span>
<span class="sd">            sage: Q.vertices()</span>
<span class="sd">            [&#39;-oo&#39;, 0, 1]</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3).framed_quiver([2, 2], vertex=&quot;a&quot;)</span>
<span class="sd">            sage: print(Q)</span>
<span class="sd">            framing of 3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 2 2]</span>
<span class="sd">            [0 0 3]</span>
<span class="sd">            [0 0 0]</span>
<span class="sd">            sage: Q.vertices()</span>
<span class="sd">            [&#39;a&#39;, 0, 1]</span>

<span class="sd">        If you frame twice it will have to use a different vertex label::</span>

<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3).framed_quiver([2, 2])</span>
<span class="sd">            sage: Q.framed_quiver([1, 1, 1]).vertices()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: -oo is already a vertex</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is already a vertex&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>

        <span class="n">framing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">framing</span><span class="p">)</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">())</span>

        <span class="c1"># adding framing the vertex (as the _first_ vertex by default)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

        <span class="c1"># adding the arrows according to the framing vector</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="o">*</span> <span class="n">framing</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;framing of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Quiver</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.coframed_quiver">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.coframed_quiver">[docs]</a>
    <span class="k">def</span> <span class="nf">coframed_quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coframing</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span><span class="s2">&quot;+oo&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coframed quiver with coframing vector ``coframing``</span>

<span class="sd">        The optional parameter ``vertex`` determines the name of the coframing vertex,</span>
<span class="sd">        which defaults to `+oo`.</span>

<span class="sd">        The coframed quiver has one additional vertex, and `f_i` many arrows from</span>
<span class="sd">        the vertex `i` to the coframed vertex, for every `i\in Q_0`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``coframing`` -- list of non-negative integers saying how many arrows go from</span>
<span class="sd">          the framed vertex to `i`</span>

<span class="sd">        - ``vertex`` (default: None) -- name of the framing vertex</span>

<span class="sd">        OUTPUT: the framed quiver</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Coframing the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3).coframed_quiver([1, 0])</span>
<span class="sd">            sage: print(Q)</span>
<span class="sd">            coframing of 3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3 1]</span>
<span class="sd">            [0 0 0]</span>
<span class="sd">            [0 0 0]</span>
<span class="sd">            sage: Q.vertices()</span>
<span class="sd">            [0, 1, &#39;+oo&#39;]</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3).coframed_quiver([2, 2], vertex=&quot;a&quot;)</span>
<span class="sd">            sage: print(Q)</span>
<span class="sd">            coframing of 3-Kronecker quiver</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3 2]</span>
<span class="sd">            [0 0 2]</span>
<span class="sd">            [0 0 0]</span>
<span class="sd">            sage: Q.vertices()</span>
<span class="sd">            [0, 1, &#39;a&#39;]</span>

<span class="sd">        If you coframe twice it will have to use a different vertex label::</span>

<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3).coframed_quiver([2, 2])</span>
<span class="sd">            sage: Q.coframed_quiver([1, 1, 1]).vertices()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: +oo is already a vertex</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is already a vertex&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>

        <span class="n">coframing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">coframing</span><span class="p">)</span>

        <span class="c1"># build the graph from the ground up</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="n">vertex</span><span class="p">],</span> <span class="p">[]],</span> <span class="n">multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># there doesn&#39;t seem to be a way to save the order of vertices otherwise</span>
        <span class="c1"># so make sure the coframing vertex appears last</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="n">vertex</span><span class="p">]))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">perm</span><span class="o">=</span><span class="n">permutation</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># adding the existing arrows</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="c1"># adding the arrows according to the framing vector</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="n">vertex</span><span class="p">)]</span> <span class="o">*</span> <span class="n">coframing</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;coframing of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Quiver</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.full_subquiver">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.full_subquiver">[docs]</a>
    <span class="k">def</span> <span class="nf">full_subquiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the full subquiver supported on the given set of vertices</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``vertices``: list of vertices for the subquiver</span>

<span class="sd">        OUTPUT: the full subquiver on the specified vertices</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some basic examples::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(2, 3, 4)</span>
<span class="sd">            sage: print(Q.full_subquiver([0, 1]))</span>
<span class="sd">            full subquiver of an acyclic 3-vertex quiver of type (2, 3, 4)</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 2]</span>
<span class="sd">            [0 0]</span>
<span class="sd">            sage: print(Q.full_subquiver([0, 2]))</span>
<span class="sd">            full subquiver of an acyclic 3-vertex quiver of type (2, 3, 4)</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [0 0]</span>

<span class="sd">        If we specified a non-standard labeling on the vertices we must use it::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a--b----c,a---c&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q == ThreeVertexQuiver(2, 3, 4)</span>
<span class="sd">            True</span>
<span class="sd">            sage: print(Q.full_subquiver([&quot;a&quot;, &quot;b&quot;]))</span>
<span class="sd">            a quiver with 2 vertices and 2 arrows</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 2]</span>
<span class="sd">            [0 0]</span>
<span class="sd">            sage: print(Q.full_subquiver([&quot;a&quot;, &quot;c&quot;]))</span>
<span class="sd">            a quiver with 2 vertices and 3 arrows</span>
<span class="sd">            adjacency matrix:</span>
<span class="sd">            [0 3]</span>
<span class="sd">            [0 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;full subquiver of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Quiver</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vertices</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dimension vectors and roots</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.zero_vector">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.zero_vector">[docs]</a>
    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">zero_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the zero dimension vector.</span>

<span class="sd">        The output is adapted to the vertices.</span>

<span class="sd">        OUTPUT: the zero dimension vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Usually it is an actual vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: KroneckerQuiver(3).zero_vector()</span>
<span class="sd">            (0, 0)</span>
<span class="sd">            sage: type(KroneckerQuiver(3).zero_vector())</span>
<span class="sd">            &lt;class &#39;sage.modules.vector_integer_dense.Vector_integer_dense&#39;&gt;</span>

<span class="sd">        But if the quiver has custom vertex labels it is a dict::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a--b----c,a---c&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.zero_vector()</span>
<span class="sd">            {&#39;a&#39;: 0, &#39;b&#39;: 0, &#39;c&#39;: 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_vertex_labels</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">vector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span></div>


<div class="viewcode-block" id="Quiver.thin_dimension_vector">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.thin_dimension_vector">[docs]</a>
    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">thin_dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the thin dimension vector, i.e., all ones</span>

<span class="sd">        The output is adapted to the vertices.</span>

<span class="sd">        OUTPUT: the thin dimension vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Usually it is an actual vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: KroneckerQuiver(3).thin_dimension_vector()</span>
<span class="sd">            (1, 1)</span>
<span class="sd">            sage: type(KroneckerQuiver(3).thin_dimension_vector())</span>
<span class="sd">            &lt;class &#39;sage.modules.vector_integer_dense.Vector_integer_dense&#39;&gt;</span>

<span class="sd">        But if the quiver has custom vertex labels it is a dict::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a--b----c,a---c&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.thin_dimension_vector()</span>
<span class="sd">            {&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 1}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_vertex_labels</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">vector</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span></div>


<div class="viewcode-block" id="Quiver.simple_root">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.simple_root">[docs]</a>
    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">simple_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the simple root at the vertex ``i``</span>

<span class="sd">        The output is adapted to the vertices.</span>

<span class="sd">        OUTPUT: the simple root at the vertex ``i``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Usually it is an actual vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: KroneckerQuiver(3).simple_root(1)</span>
<span class="sd">            (0, 1)</span>
<span class="sd">            sage: type(KroneckerQuiver(3).simple_root(1))</span>
<span class="sd">            &lt;class &#39;sage.modules.vector_integer_dense.Vector_integer_dense&#39;&gt;</span>

<span class="sd">        But if the quiver has custom vertex labels it is a dict::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a--b----c,a---c&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.simple_root(&quot;b&quot;)</span>
<span class="sd">            {&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 0}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_vertex_labels</span><span class="p">():</span>
            <span class="n">root</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
        <span class="n">root</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">root</span></div>


<div class="viewcode-block" id="Quiver.is_root">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_root">[docs]</a>
    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks whether ``x`` is a root of the underlying diagram of the quiver.</span>

<span class="sd">        A root is a non-zero vector `x` in :math:`\mathbb{Z}Q_0` such that</span>
<span class="sd">        the Tits form of `x` is at most 1.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x``: integer vector</span>

<span class="sd">        OUTPUT: whether ``x`` is a root</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some roots and non-roots for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_root([2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_root(Q.zero_vector())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.is_root([4, 1])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Quiver.is_real_root">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_real_root">[docs]</a>
    <span class="k">def</span> <span class="nf">is_real_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks whether ``x`` is a real root of the underlying diagram of the quiver.</span>

<span class="sd">        A root is called real if its Tits form equals 1.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x``: integer vector</span>

<span class="sd">        OUTPUT: whether ``x`` is a real root</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some real and non-real for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_real_root([2, 3])</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.is_real_root(Q.zero_vector())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.is_real_root([3, 1])</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Quiver.is_imaginary_root">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_imaginary_root">[docs]</a>
    <span class="k">def</span> <span class="nf">is_imaginary_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks whether ``x`` is a imaginary root of the quiver.</span>

<span class="sd">        A root is called imaginary if its Tits form is non-positive.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``x``: integer vector</span>

<span class="sd">        OUTPUT: whether ``x`` is an imaginary root</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some imaginary roots and non imaginary roots for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_imaginary_root([2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_imaginary_root(Q.zero_vector())</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.is_imaginary_root([4, 1])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Quiver.is_schur_root">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_schur_root">[docs]</a>
    <span class="k">def</span> <span class="nf">is_schur_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if ``d`` is a Schur root.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        OUTPUT: whether ``d`` is an imaginary root</span>

<span class="sd">        A Schur root is a dimension vector which admits a Schurian representation,</span>
<span class="sd">        i.e., a representation whose endomorphism ring is the field itself.</span>
<span class="sd">        It is necessarily indecomposable.</span>
<span class="sd">        By MR1162487_ `d` is a Schur root if and only if `d` admits a stable</span>
<span class="sd">        representation for the canonical stability parameter.</span>

<span class="sd">        .. _MR1162487: https://mathscinet.ams.org/mathscinet/relay-station?mr=1162487</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The dimension vector `(2, 3)` is Schurian for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_schur_root([2, 3])</span>
<span class="sd">            True</span>

<span class="sd">        Examples from Derksen--Weyman&#39;s book (Example 11.1.4)::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(1, 1, 1)</span>
<span class="sd">            sage: Q.is_schur_root([1, 1, 2])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_schur_root([1, 2, 1])</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.is_schur_root([1, 1, 1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_schur_root([2, 2, 2])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.slope">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.slope">[docs]</a>
    <span class="k">def</span> <span class="nf">slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the slope of ``d`` with respect to ``theta``</span>

<span class="sd">        The slope is defined as the value of `theta(d)` divided by the total dimension</span>
<span class="sd">        of `d`. It is possible to vary the denominator, to use a function more general</span>
<span class="sd">        than the sum.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` -- dimension vector</span>

<span class="sd">        - ``theta`` -- (default: canonical stability parameter) stability parameter</span>

<span class="sd">        - ``denom`` -- (default: sum) the denominator function</span>

<span class="sd">        OUTPUT: the slope of ``d`` with respect to ``theta`` and optional ``denom``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some slopes for the Kronecker quiver, first for the canonical stability</span>
<span class="sd">        parameter, then for some other::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: d = [2, 3]</span>
<span class="sd">            sage: Q.slope(d, [9, -6])</span>
<span class="sd">            0</span>
<span class="sd">            sage: Q.slope(d)</span>
<span class="sd">            0</span>
<span class="sd">            sage: Q.slope(d, [2, -2])</span>
<span class="sd">            -2/5</span>

<span class="sd">        We can use for instance a constant denominator::</span>

<span class="sd">            sage: constant = lambda di: 1</span>
<span class="sd">            sage: Q.slope(d, Q.canonical_stability_parameter(d), denom=constant)</span>
<span class="sd">            0</span>

<span class="sd">        The only dependence on the quiver is the set of vertices, so if we don&#39;t</span>
<span class="sd">        use vertex labels, the choice of quiver doesn&#39;t matter::</span>

<span class="sd">            sage: d, theta = [2, 3], [9, -6]</span>
<span class="sd">            sage: KroneckerQuiver(3).slope(d, theta)</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">denom</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">theta</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.is_subdimension_vector">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_subdimension_vector">[docs]</a>
    <span class="k">def</span> <span class="nf">is_subdimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether ``e`` is a subdimension vector of ``d``</span>

<span class="sd">        INPUT:</span>

<span class="sd">        -- ``e`` -- dimension vector</span>

<span class="sd">        -- ``d`` -- dimension vector</span>

<span class="sd">        OUTPUT: whether ``e`` is a subdimension vector of ``d``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some basic examples::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_subdimension_vector([1, 2], [2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_subdimension_vector([2, 3], [2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_subdimension_vector([6, 6], [2, 3])</span>
<span class="sd">            False</span>

<span class="sd">        We can also work with vertex labels::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a--b----c,a---c&quot;, forget_labels=False)</span>
<span class="sd">            sage: d = {&quot;a&quot; : 3, &quot;b&quot; : 3, &quot;c&quot; : 3}</span>
<span class="sd">            sage: e = {&quot;a&quot; : 1, &quot;b&quot; : 2, &quot;c&quot; : 3}</span>
<span class="sd">            sage: Q.is_subdimension_vector(e, d)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_subdimension_vector(d, e)</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">ei</span> <span class="o">&lt;=</span> <span class="n">di</span> <span class="k">for</span> <span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">_deglex_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An integer representation of a dimension vector</span>

<span class="sd">        This is the base-b expansion of a dimension vector.</span>

<span class="sd">        This is a function which satisfies</span>

<span class="sd">            e &lt;_{deglex} d iff deglex_key(e) &lt; deglex_key(d),</span>

<span class="sd">        provided that b &gt;&gt; 0.</span>

<span class="sd">        For b &gt;&gt; 0 the deglex order is a _total_ order which extends the usual</span>
<span class="sd">        entry-wise partial order on dimension vectors.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``e`` -- dimension vector</span>

<span class="sd">        - ``b`` -- the &quot;base&quot; of the key (default: `max(e)+1`)</span>

<span class="sd">        OUTPUT: the base-`b` expansion of the dimension vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        If we let `b` be the largest entry plus one we get a good key, at least for</span>
<span class="sd">        subdimension vectors of the original one::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: d = [2, 3]</span>
<span class="sd">            sage: Q._deglex_key(d, max(d) + 1)</span>
<span class="sd">            91</span>
<span class="sd">            sage: d = [3, 3]</span>
<span class="sd">            sage: Q._deglex_key(d)</span>
<span class="sd">            111</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">ei</span> <span class="o">*</span> <span class="n">b</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ei</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="o">*</span> <span class="n">b</span><span class="o">**</span><span class="n">n</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Quiver.all_subdimension_vectors">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.all_subdimension_vectors">[docs]</a>
    <span class="k">def</span> <span class="nf">all_subdimension_vectors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all subdimension vectors of d.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` -- dimension vector</span>

<span class="sd">        - ``proper`` (default: False) -- whether to exclude ``d``</span>

<span class="sd">        - ``nonzero`` (default: False) -- whether to exclude the zero vector</span>

<span class="sd">        - ``forget_labels`` (default: False) -- whether to forget the vertex labels</span>

<span class="sd">        OUTPUT: all subdimension vectors of ``d`` (maybe excluding zero and/or ``d``)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The usual use cases::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.all_subdimension_vectors([2, 3])</span>
<span class="sd">                [(0, 0),</span>
<span class="sd">                 (0, 1),</span>
<span class="sd">                 (0, 2),</span>
<span class="sd">                 (0, 3),</span>
<span class="sd">                 (1, 0),</span>
<span class="sd">                 (1, 1),</span>
<span class="sd">                 (1, 2),</span>
<span class="sd">                 (1, 3),</span>
<span class="sd">                 (2, 0),</span>
<span class="sd">                 (2, 1),</span>
<span class="sd">                 (2, 2),</span>
<span class="sd">                 (2, 3)]</span>
<span class="sd">            sage: Q.all_subdimension_vectors([2, 3], proper=True)</span>
<span class="sd">                [(0, 0),</span>
<span class="sd">                 (0, 1),</span>
<span class="sd">                 (0, 2),</span>
<span class="sd">                 (0, 3),</span>
<span class="sd">                 (1, 0),</span>
<span class="sd">                 (1, 1),</span>
<span class="sd">                 (1, 2),</span>
<span class="sd">                 (1, 3),</span>
<span class="sd">                 (2, 0),</span>
<span class="sd">                 (2, 1),</span>
<span class="sd">                 (2, 2)]</span>
<span class="sd">            sage: Q.all_subdimension_vectors([2, 3], nonzero=True)</span>
<span class="sd">                [(0, 1),</span>
<span class="sd">                 (0, 2),</span>
<span class="sd">                 (0, 3),</span>
<span class="sd">                 (1, 0),</span>
<span class="sd">                 (1, 1),</span>
<span class="sd">                 (1, 2),</span>
<span class="sd">                 (1, 3),</span>
<span class="sd">                 (2, 0),</span>
<span class="sd">                 (2, 1),</span>
<span class="sd">                 (2, 2),</span>
<span class="sd">                 (2, 3)]</span>
<span class="sd">            sage: Q.all_subdimension_vectors([2, 3], proper=True, nonzero=True)</span>
<span class="sd">                [(0, 1),</span>
<span class="sd">                 (0, 2),</span>
<span class="sd">                 (0, 3),</span>
<span class="sd">                 (1, 0),</span>
<span class="sd">                 (1, 1),</span>
<span class="sd">                 (1, 2),</span>
<span class="sd">                 (1, 3),</span>
<span class="sd">                 (2, 0),</span>
<span class="sd">                 (2, 1),</span>
<span class="sd">                 (2, 2)]</span>

<span class="sd">        Some exceptional cases::</span>

<span class="sd">            sage: Q.all_subdimension_vectors(Q.zero_vector())</span>
<span class="sd">            [(0, 0)]</span>
<span class="sd">            sage: Q.all_subdimension_vectors(Q.zero_vector(), proper=True)</span>
<span class="sd">            []</span>

<span class="sd">        If we work with labeled vertices, then we get a list of dicts::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a---b&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.all_subdimension_vectors([1, 2])</span>
<span class="sd">            [{&#39;a&#39;: 0, &#39;b&#39;: 0},</span>
<span class="sd">             {&#39;a&#39;: 0, &#39;b&#39;: 1},</span>
<span class="sd">             {&#39;a&#39;: 0, &#39;b&#39;: 2},</span>
<span class="sd">             {&#39;a&#39;: 1, &#39;b&#39;: 0},</span>
<span class="sd">             {&#39;a&#39;: 1, &#39;b&#39;: 1},</span>
<span class="sd">             {&#39;a&#39;: 1, &#39;b&#39;: 2}]</span>
<span class="sd">            sage: Q.all_subdimension_vectors([1, 2], forget_labels=True)</span>
<span class="sd">            [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># if zero dimension vector we deal with it separately</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">proper</span> <span class="ow">or</span> <span class="n">nonzero</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

        <span class="n">vectors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cartesian_product</span><span class="p">([</span><span class="nb">range</span><span class="p">(</span><span class="n">di</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">proper</span><span class="p">:</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nonzero</span><span class="p">:</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_vertex_labels</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">forget_labels</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">e</span><span class="p">)),</span> <span class="n">vectors</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">vectors</span><span class="p">))</span></div>


<div class="viewcode-block" id="Quiver.is_theta_coprime">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_theta_coprime">[docs]</a>
    <span class="k">def</span> <span class="nf">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if ``d`` is ``theta``-coprime.</span>

<span class="sd">        A dimension vector `d` is :math:`\theta`-coprime if</span>
<span class="sd">        :math:`\mu_{\theta}(e)\neq \mu_{\theta}(e)`</span>
<span class="sd">        for all proper non-zero subdimension vectors e of d.</span>

<span class="sd">        The default value for ``theta`` is the canonical stability parameter.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` -- dimension vector</span>

<span class="sd">        - ``theta`` -- (default: canonical stability paramter) stability parameter</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Examples of coprimality::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: d = [2, 3]</span>
<span class="sd">            sage: Q.is_theta_coprime(d, Q.canonical_stability_parameter(d))</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_theta_coprime(d)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_theta_coprime([3, 3], [1, -1])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vectors</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.is_indivisible">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_indivisible">[docs]</a>
    <span class="k">def</span> <span class="nf">is_indivisible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the gcd of all entries of ``d`` is 1</span>

<span class="sd">        INPUT:</span>

<span class="sd">        -- ``d`` -- dimension vector</span>

<span class="sd">        OUTPUT: whether the dimension vector is indivisible</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Two examples with the Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.is_indivisible([2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.is_indivisible([2, 2])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Quiver.support">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.support">[docs]</a>
    <span class="k">def</span> <span class="nf">support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the support of the dimension vector.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        OUTPUT: subset of vertices in the underlying graph in the support</span>

<span class="sd">        The support is the set :math:`\{ i \in Q_0 \mid d_i &gt; 0 \}`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The support is the set of vertices for which the value of the dimension</span>
<span class="sd">        vector is nonzero::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(2, 0, 4)</span>
<span class="sd">            sage: d = vector([1, 1, 1])</span>
<span class="sd">            sage: Q.support(d)</span>
<span class="sd">            [0, 1, 2]</span>
<span class="sd">            sage: d = vector([1, 0, 1])</span>
<span class="sd">            sage: Q.support(d)</span>
<span class="sd">            [0, 2]</span>

<span class="sd">        It takes into account vertex labels::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a--b----c,a---c&quot;, forget_labels=False)</span>
<span class="sd">            sage: d = {&quot;a&quot;: 2, &quot;b&quot;: 3, &quot;c&quot;: 0}</span>
<span class="sd">            sage: Q.support(d)</span>
<span class="sd">            [&#39;a&#39;, &#39;b&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Quiver.in_fundamental_domain">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.in_fundamental_domain">[docs]</a>
    <span class="k">def</span> <span class="nf">in_fundamental_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if a dimension vector is in the fundamental domain.</span>

<span class="sd">        The fundamental domain of :math:`Q` is the set of dimension vectors :math:`d`</span>
<span class="sd">        such that</span>

<span class="sd">        - :math:`\operatorname{supp}(\mathbf{d})` is connected</span>
<span class="sd">        - :math:`\langle d,e_i\rangle + \langle e_i,d\rangle\leq 0` for every simple</span>
<span class="sd">          root</span>

<span class="sd">        Every :math:`d` in the fundamental domain is an imaginary root and the set of</span>
<span class="sd">        imaginary roots is the Weyl group saturation of the fundamental domain.</span>
<span class="sd">        If :math:`d` is in the fundamental domain then it is Schurian and a general</span>
<span class="sd">        representation of dimension vector :math:`d` is stable for the canonical</span>
<span class="sd">        stability parameter.</span>

<span class="sd">        The optional parameter ``depth`` allows to make the inequality stricter.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        - ``depth`` (default: 0) -- how deep the vector should be in the domain</span>

<span class="sd">        OUTPUT: whether ``d`` is in the (interior of) the fundamental domain</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The fundamental domain of the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.in_fundamental_domain([1, 1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.in_fundamental_domain([1, 2])</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.in_fundamental_domain([2, 3])</span>
<span class="sd">            True</span>

<span class="sd">        The same calculation now with vertex labels::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;a---b&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.in_fundamental_domain({&quot;a&quot; : 1, &quot;b&quot; : 1})</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.in_fundamental_domain({&quot;a&quot; : 1, &quot;b&quot; : 2})</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.in_fundamental_domain({&quot;a&quot; : 2, &quot;b&quot; : 3})</span>
<span class="sd">            True</span>

<span class="sd">        We test for dimension vectors in the strict interior, where the depth is</span>
<span class="sd">        equal to 1::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.in_fundamental_domain([1, 1], depth=1)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.in_fundamental_domain([2, 3], depth=1)</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># check if `\langle d,e_i\rangle + \langle e_i,d\rangle \leq 0`</span>
        <span class="c1"># for all vertices `i\in Q_0`</span>
        <span class="n">inequality</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmetrized_euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simple_root</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">depth</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># check if the support is connected</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_subquiver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">(</span><span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">inequality</span> <span class="ow">and</span> <span class="n">connected</span></div>


<div class="viewcode-block" id="Quiver.division_order">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.division_order">[docs]</a>
    <span class="k">def</span> <span class="nf">division_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if `d\ll e`</span>

<span class="sd">        This means that</span>

<span class="sd">        - :math:`d_i \leq e_i` for every source `i`</span>
<span class="sd">        - :math:`d_j \geq e_j` for every sink `j`,</span>
<span class="sd">        - :math:`d_k = e_k` for every vertex `k` which is neither a source nor a sink.</span>

<span class="sd">        This is used when dealing with Chow rings of quiver moduli, see also</span>
<span class="sd">        :meth:`QuiverModuli._all_minimal_forbidden_subdimension_vectors`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The division order on some dimension vectors for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: d = [1, 1]</span>
<span class="sd">            sage: e = [2, 1]</span>
<span class="sd">            sage: f = [2, 2]</span>
<span class="sd">            sage: Q.division_order(d, e)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.division_order(e, d)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.division_order(d, f)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.division_order(f, d)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.division_order(e, f)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.division_order(f, e)</span>
<span class="sd">            True</span>

<span class="sd">        The division order on some dimension vectors for a 3-vertex quiver::</span>

<span class="sd">            sage: Q = ThreeVertexQuiver(2, 2, 2)</span>
<span class="sd">            sage: d = [1, 1, 1]</span>
<span class="sd">            sage: e = [1, 2, 1]</span>
<span class="sd">            sage: Q.division_order(d, e)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.division_order(e, d)</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sources</span><span class="p">())</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sinks</span><span class="p">())</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sources</span><span class="p">()</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sinks</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic subdimension vectors and generic Hom and Ext</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.is_generic_subdimension_vector">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.is_generic_subdimension_vector">[docs]</a>
    <span class="nd">@cached_method</span><span class="p">(</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_generic_subdimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if e is a generic subdimension vector of d.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``e``: dimension vector for the subrepresentation</span>

<span class="sd">        - ``d``: dimension vector for the ambient representation</span>

<span class="sd">        OUTPUT: whether e is a generic subdimension vector of d</span>

<span class="sd">        A dimension vector `e` is a generic subdimension vector of `d`</span>
<span class="sd">        if a generic representation of dimension vector `d` possesses</span>
<span class="sd">        a subrepresentation of dimension vector `e`.</span>
<span class="sd">        By a result of Schofield (see Thm. 5.3 of https://arxiv.org/pdf/0802.2147.pdf)</span>
<span class="sd">        By MR1162487_ `e` is a generic subdimension vector of `d` if and only if `e` is</span>
<span class="sd">        a subdimension vector of `d` and :math:`\langle f,d-e\rangle` is non-negative</span>
<span class="sd">        for all generic subdimension vectors `f` of `e`.</span>

<span class="sd">        .. _MR1162487: https://mathscinet.ams.org/mathscinet/relay-station?mr=1162487</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some examples on loop quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = LoopQuiver(1)</span>
<span class="sd">            sage: ds = [vector([i]) for i in range(3)]</span>
<span class="sd">            sage: for (e, d) in cartesian_product([ds, ds]):</span>
<span class="sd">            ....:     if not Q.is_subdimension_vector(e, d): continue</span>
<span class="sd">            ....:     print(&quot;{} is generic subdimension vector of {}: {}&quot;.format(</span>
<span class="sd">            ....:         e, d, Q.is_generic_subdimension_vector(e,d))</span>
<span class="sd">            ....:     )</span>
<span class="sd">            (0) is generic subdimension vector of (0): True</span>
<span class="sd">            (0) is generic subdimension vector of (1): True</span>
<span class="sd">            (0) is generic subdimension vector of (2): True</span>
<span class="sd">            (1) is generic subdimension vector of (1): True</span>
<span class="sd">            (1) is generic subdimension vector of (2): True</span>
<span class="sd">            (2) is generic subdimension vector of (2): True</span>
<span class="sd">            sage: Q = LoopQuiver(2)</span>
<span class="sd">            sage: for (e, d) in cartesian_product([ds]*2):</span>
<span class="sd">            ....:     if not Q.is_subdimension_vector(e, d): continue</span>
<span class="sd">            ....:     print(&quot;{} is generic subdimension vector of {}: {}&quot;.format(</span>
<span class="sd">            ....:         e, d, Q.is_generic_subdimension_vector(e,d))</span>
<span class="sd">            ....:     )</span>
<span class="sd">            (0) is generic subdimension vector of (0): True</span>
<span class="sd">            (0) is generic subdimension vector of (1): True</span>
<span class="sd">            (0) is generic subdimension vector of (2): True</span>
<span class="sd">            (1) is generic subdimension vector of (1): True</span>
<span class="sd">            (1) is generic subdimension vector of (2): False</span>
<span class="sd">            (2) is generic subdimension vector of (2): True</span>

<span class="sd">        Some examples on generalized Kronecker quivers::</span>

<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: ds = Tuples(range(3), 2)</span>
<span class="sd">            sage: for (e, d) in cartesian_product([ds]*2):</span>
<span class="sd">            ....:     if not Q.is_subdimension_vector(e, d): continue</span>
<span class="sd">            ....:     print(&quot;{} is generic subdimension vector of {}: {}&quot;.format(</span>
<span class="sd">            ....:         e, d, Q.is_generic_subdimension_vector(e,d))</span>
<span class="sd">            ....:     )</span>
<span class="sd">            (0, 0) is generic subdimension vector of (0, 0): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (1, 0): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (2, 0): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (0, 1): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (1, 1): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (0, 2): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (1, 0) is generic subdimension vector of (1, 0): True</span>
<span class="sd">            (1, 0) is generic subdimension vector of (2, 0): True</span>
<span class="sd">            (1, 0) is generic subdimension vector of (1, 1): False</span>
<span class="sd">            (1, 0) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (1, 0) is generic subdimension vector of (1, 2): False</span>
<span class="sd">            (1, 0) is generic subdimension vector of (2, 2): False</span>
<span class="sd">            (2, 0) is generic subdimension vector of (2, 0): True</span>
<span class="sd">            (2, 0) is generic subdimension vector of (2, 1): False</span>
<span class="sd">            (2, 0) is generic subdimension vector of (2, 2): False</span>
<span class="sd">            (0, 1) is generic subdimension vector of (0, 1): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (1, 1): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (0, 2): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (1, 1) is generic subdimension vector of (1, 1): True</span>
<span class="sd">            (1, 1) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (1, 1) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (1, 1) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (2, 1) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (2, 1) is generic subdimension vector of (2, 2): False</span>
<span class="sd">            (0, 2) is generic subdimension vector of (0, 2): True</span>
<span class="sd">            (0, 2) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (0, 2) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (1, 2) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (1, 2) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (2, 2) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(2)</span>
<span class="sd">            sage: for (e, d) in cartesian_product([ds]*2):</span>
<span class="sd">            ....:     if not Q.is_subdimension_vector(e, d): continue</span>
<span class="sd">            ....:     print(&quot;{} is generic subdimension vector of {}: {}&quot;.format(</span>
<span class="sd">            ....:         e, d, Q.is_generic_subdimension_vector(e,d))</span>
<span class="sd">            ....:     )</span>
<span class="sd">            (0, 0) is generic subdimension vector of (0, 0): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (1, 0): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (2, 0): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (0, 1): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (1, 1): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (0, 2): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (0, 0) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (1, 0) is generic subdimension vector of (1, 0): True</span>
<span class="sd">            (1, 0) is generic subdimension vector of (2, 0): True</span>
<span class="sd">            (1, 0) is generic subdimension vector of (1, 1): False</span>
<span class="sd">            (1, 0) is generic subdimension vector of (2, 1): False</span>
<span class="sd">            (1, 0) is generic subdimension vector of (1, 2): False</span>
<span class="sd">            (1, 0) is generic subdimension vector of (2, 2): False</span>
<span class="sd">            (2, 0) is generic subdimension vector of (2, 0): True</span>
<span class="sd">            (2, 0) is generic subdimension vector of (2, 1): False</span>
<span class="sd">            (2, 0) is generic subdimension vector of (2, 2): False</span>
<span class="sd">            (0, 1) is generic subdimension vector of (0, 1): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (1, 1): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (0, 2): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (0, 1) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (1, 1) is generic subdimension vector of (1, 1): True</span>
<span class="sd">            (1, 1) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (1, 1) is generic subdimension vector of (1, 2): False</span>
<span class="sd">            (1, 1) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (2, 1) is generic subdimension vector of (2, 1): True</span>
<span class="sd">            (2, 1) is generic subdimension vector of (2, 2): False</span>
<span class="sd">            (0, 2) is generic subdimension vector of (0, 2): True</span>
<span class="sd">            (0, 2) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (0, 2) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (1, 2) is generic subdimension vector of (1, 2): True</span>
<span class="sd">            (1, 2) is generic subdimension vector of (2, 2): True</span>
<span class="sd">            (2, 2) is generic subdimension vector of (2, 2): True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">d</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">ei</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">e</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_subdimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">eprime</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">eprime</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_generic_subdimension_vector</span><span class="p">(</span><span class="n">eprime</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">eprime</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.all_generic_subdimension_vectors">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.all_generic_subdimension_vectors">[docs]</a>
    <span class="k">def</span> <span class="nf">all_generic_subdimension_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all generic subdimension vectors of ``d``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        OUTPUT: list of vectors</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some n-Kronecker quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: d = vector([3,3])</span>
<span class="sd">            sage: Q.all_generic_subdimension_vectors(d)</span>
<span class="sd">            [(0, 0),</span>
<span class="sd">             (0, 1),</span>
<span class="sd">             (0, 2),</span>
<span class="sd">             (0, 3),</span>
<span class="sd">             (1, 1),</span>
<span class="sd">             (1, 2),</span>
<span class="sd">             (1, 3),</span>
<span class="sd">             (2, 2),</span>
<span class="sd">             (2, 3),</span>
<span class="sd">             (3, 3)]</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(2)</span>
<span class="sd">            sage: Q.all_generic_subdimension_vectors(d)</span>
<span class="sd">            [(0, 0),</span>
<span class="sd">             (0, 1),</span>
<span class="sd">             (0, 2),</span>
<span class="sd">             (0, 3),</span>
<span class="sd">             (1, 1),</span>
<span class="sd">             (1, 2),</span>
<span class="sd">             (1, 3),</span>
<span class="sd">             (2, 2),</span>
<span class="sd">             (2, 3),</span>
<span class="sd">             (3, 3)]</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.all_generic_subdimension_vectors(d)</span>
<span class="sd">            [(0, 0), (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (3, 3)]</span>
<span class="sd">            sage: Q.all_generic_subdimension_vectors(d, nonzero=True)</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (3, 3)]</span>
<span class="sd">            sage: Q.all_generic_subdimension_vectors(d, proper=True)</span>
<span class="sd">            [(0, 0), (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_generic_subdimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="n">proper</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="n">nonzero</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.generic_ext">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.generic_ext">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes :math:`\operatorname{ext}(d, e)`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        - ``e``: dimension vector</span>

<span class="sd">        OUTPUT: dimension of the generic ext</span>

<span class="sd">        According to Theorem 5.4 in Schofield&#39;s &#39;General representations of quivers&#39;,</span>
<span class="sd">        we have</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \operatorname{ext}(a,b) =</span>
<span class="sd">            \operatorname{max}\{-\langle c,b\rangle\}.</span>

<span class="sd">        where :math:`c` runs over the generic subdimension vectors of :math:`a`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Generic ext on the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: ds = [Q.simple_root(0), Q.simple_root(1), Q.thin_dimension_vector()]</span>
<span class="sd">            sage: for (d, e) in cartesian_product([ds]*2):</span>
<span class="sd">            ....:     print(&quot;ext({}, {}) = {}&quot;.format(d, e, Q.generic_ext(d, e)))</span>
<span class="sd">            ext((1, 0), (1, 0)) = 0</span>
<span class="sd">            ext((1, 0), (0, 1)) = 3</span>
<span class="sd">            ext((1, 0), (1, 1)) = 2</span>
<span class="sd">            ext((0, 1), (1, 0)) = 0</span>
<span class="sd">            ext((0, 1), (0, 1)) = 0</span>
<span class="sd">            ext((0, 1), (1, 1)) = 0</span>
<span class="sd">            ext((1, 1), (1, 0)) = 0</span>
<span class="sd">            ext((1, 1), (0, 1)) = 2</span>
<span class="sd">            ext((1, 1), (1, 1)) = 1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_generic_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.generic_hom">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.generic_hom">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_hom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes :math:`\operatorname{hom}(d, e)`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        - ``e``: dimension vector</span>

<span class="sd">        OUTPUT: dimension of the generic hom</span>

<span class="sd">        There is a non-empty open subset `U` of :math:`R(Q,d) \times R(Q,e)` such that</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \operatorname{dim}(\operatorname{Ext}(M,N)) = \operatorname{ext}(d,e),</span>

<span class="sd">        i.e., :math:`\operatorname{dim}(\operatorname{Ext}(M,N))` is minimal for all</span>
<span class="sd">        `(M,N)` in `U`.</span>

<span class="sd">        Therefore, `\operatorname{dim}(\operatorname{Hom}(M,N)) =</span>
<span class="sd">        \langle a,b\rangle + \operatorname{dim}(\operatorname{Ext}(M,N))`</span>
<span class="sd">        is minimal, and</span>
<span class="sd">        `\operatorname{hom}(a,b) = \langle a,b\rangle + \operatorname{ext}(a,b)`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Generic hom on the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: ds = [Q.simple_root(0), Q.simple_root(1), Q.thin_dimension_vector()]</span>
<span class="sd">            sage: for (d, e) in cartesian_product([ds]*2):</span>
<span class="sd">            ....:     print(&quot;hom({}, {}) = {}&quot;.format(d, e, Q.generic_hom(d, e)))</span>
<span class="sd">            hom((1, 0), (1, 0)) = 1</span>
<span class="sd">            hom((1, 0), (0, 1)) = 0</span>
<span class="sd">            hom((1, 0), (1, 1)) = 0</span>
<span class="sd">            hom((0, 1), (1, 0)) = 0</span>
<span class="sd">            hom((0, 1), (0, 1)) = 1</span>
<span class="sd">            hom((0, 1), (1, 1)) = 1</span>
<span class="sd">            hom((1, 1), (1, 0)) = 1</span>
<span class="sd">            hom((1, 1), (0, 1)) = 0</span>
<span class="sd">            hom((1, 1), (1, 1)) = 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_ext</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Harder--Narasimhan types</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.all_hn_types">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.all_hn_types">[docs]</a>
    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">all_hn_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all Harder--Narasimhan types of d.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` -- dimension vector</span>

<span class="sd">        - ``theta` -- stability parameter</span>

<span class="sd">        - ``denom`` -- the denominator function (default: sum)</span>

<span class="sd">        OUTPUT: list of Harder--Narasimhan types</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Harder--Narasimhan types for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: d = (2, 3)</span>
<span class="sd">            sage: theta = (3, -2)</span>
<span class="sd">            sage: Q.all_hn_types(d, theta)</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
                <span class="n">ds</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">sorted</span><span class="p">:</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)))</span>

        <span class="n">all_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">estar</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">fstar</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">fstar</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_hn_types</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="n">all_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,)</span> <span class="o">+</span> <span class="n">estar</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">):</span>
            <span class="n">all_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">all_types</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (Semi-)stability</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.canonical_stability_parameter">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.canonical_stability_parameter">[docs]</a>
    <span class="k">def</span> <span class="nf">canonical_stability_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the canonical stability parameter for ``d``</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        OUTPUT: canonical stability parameter</span>

<span class="sd">        The canonical stability parameter is given by</span>
<span class="sd">        `\langle d,-\rangle - \langle -,d\rangle`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` -- dimension vector to be used</span>

<span class="sd">        OUTPUT: canonical stability parameter for ``d``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Our usual example of the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.canonical_stability_parameter([2, 3])</span>
<span class="sd">            (9, -6)</span>

<span class="sd">        For the 5-subspace quiver::</span>

<span class="sd">            sage: Q = SubspaceQuiver(5)</span>
<span class="sd">            sage: Q.canonical_stability_parameter([1, 1, 1, 1, 1, 2])</span>
<span class="sd">            (2, 2, 2, 2, 2, -5)</span>

<span class="sd">        It takes vertex labels (if present) into account::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: Q.canonical_stability_parameter([2, 3])</span>
<span class="sd">            {&#39;bar&#39;: -6, &#39;foo&#39;: 9}</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Canonical stability parameter for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2, 3])</span>
<span class="sd">            sage: Q.canonical_stability_parameter(d)</span>
<span class="sd">            (9, -6)</span>

<span class="sd">        This method also works with vertex labels::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: d = {&quot;foo&quot;: 2, &quot;bar&quot;: 3}</span>
<span class="sd">            sage: Q.canonical_stability_parameter(d)</span>
<span class="sd">            {&#39;bar&#39;: -6, &#39;foo&#39;: 9}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">euler_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">euler_matrix</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__has_vertex_labels</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">theta</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">theta</span></div>


<div class="viewcode-block" id="Quiver.has_semistable_representation">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.has_semistable_representation">[docs]</a>
    <span class="k">def</span> <span class="nf">has_semistable_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if there is a ``theta``-semistable of dimension vector `d`</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        - ``theta`` (default: canonical stability parameter): stability parameter</span>

<span class="sd">        OUTPUT: whether there is a ``theta``-semistable of dimension vector `d`</span>

<span class="sd">        By MR1162486_ a dimension vector `d` admits a :math:`\theta`-semi-stable</span>
<span class="sd">        representation if and only if :math:`\mu_{\theta}(e) &lt;= \mu_{\theta}(d)` for</span>
<span class="sd">        all generic subdimension vectors `e` of `d`.</span>

<span class="sd">        .. _MR1162487: https://mathscinet.ams.org/mathscinet/relay-station?mr=1162487</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Semistables for the :math:`\mathrm{A}_2` quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: Q.has_semistable_representation([1, 1], [1, -1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.has_semistable_representation([2, 2], [1, -1])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.has_semistable_representation([1, 2], [1, -1])</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.has_semistable_representation([0, 0], [1, -1])</span>
<span class="sd">            True</span>

<span class="sd">        Semistables for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.has_semistable_representation([2, 3])</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.has_semistable_representation([1, 4], [-3, 2])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_generic_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Quiver.has_stable_representation">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.has_stable_representation">[docs]</a>
    <span class="k">def</span> <span class="nf">has_stable_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if there is a ``theta``-stable representation of this dimension vector</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        - ``theta`` (default: canonical stability parameter): stability parameter</span>

<span class="sd">        OUTPUT: whether there is a ``theta``-stable of dimension vector ``d``</span>

<span class="sd">        By MR1162487_ `d` admits a theta-stable representation if and only if</span>
<span class="sd">        :math:`\mu_{\theta}(e) &lt; \mu_{\theta}(d)` for all proper generic subdimension</span>
<span class="sd">        vectors :math:`e` of :math:`d`.</span>

<span class="sd">        .. _MR1162487: https://mathscinet.ams.org/mathscinet/relay-station?mr=1162487</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Stables for the :math:`\mathrm{A}_2` quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: theta = (1, -1)</span>
<span class="sd">            sage: Q.has_stable_representation([1, 1], theta)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.has_stable_representation([2, 2], theta)</span>
<span class="sd">            False</span>
<span class="sd">            sage: Q.has_stable_representation([0, 0], theta)</span>
<span class="sd">            False</span>

<span class="sd">        Stables for the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: d = (2, 3)</span>
<span class="sd">            sage: theta = Q.canonical_stability_parameter(d)</span>
<span class="sd">            sage: Q.has_stable_representation(d, theta)</span>
<span class="sd">            True</span>
<span class="sd">            sage: Q.has_stable_representation(d)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_generic_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Canonical decomposition</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Quiver.canonical_decomposition">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.canonical_decomposition">[docs]</a>
    <span class="nd">@cached_method</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">canonical_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the canonical decomposition of a dimension vector.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d``: dimension vector</span>

<span class="sd">        OUTPUT: canonical decomposition as list of dimension vectors</span>

<span class="sd">        The canonical decomposition of a dimension vector `d` is the unique</span>
<span class="sd">        decomposition :math:`d = e_1 + e_2 + ... + e_k` such that</span>
<span class="sd">        :math:`e_1, e_2, ..., e_k` are such that for all</span>
<span class="sd">        :math:`i \neq j, \mathrm{ext}(e_i, e_j) = \mathrm{ext}(e_j, e_i) = 0`.</span>

<span class="sd">        The general representation of dimension vector `d` is isomorphic to the direct</span>
<span class="sd">        sum of representations of dimension vectors :math:`e_1, e_2, ..., e_k`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Canonical decomposition of the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q.canonical_decomposition((2,3))</span>
<span class="sd">            [(2, 3)]</span>
<span class="sd">            sage: for d in Q.all_subdimension_vectors((5, 5)):</span>
<span class="sd">            ....:     print(Q.canonical_decomposition(d))</span>
<span class="sd">            [(0, 0)]</span>
<span class="sd">            [(0, 1)]</span>
<span class="sd">            [(0, 1), (0, 1)]</span>
<span class="sd">            [(0, 1), (0, 1), (0, 1)]</span>
<span class="sd">            [(0, 1), (0, 1), (0, 1), (0, 1)]</span>
<span class="sd">            [(0, 1), (0, 1), (0, 1), (0, 1), (0, 1)]</span>
<span class="sd">            [(1, 0)]</span>
<span class="sd">            [(1, 1)]</span>
<span class="sd">            [(1, 2)]</span>
<span class="sd">            [(1, 3)]</span>
<span class="sd">            [(0, 1), (1, 3)]</span>
<span class="sd">            [(0, 1), (0, 1), (1, 3)]</span>
<span class="sd">            [(1, 0), (1, 0)]</span>
<span class="sd">            [(2, 1)]</span>
<span class="sd">            [(2, 2)]</span>
<span class="sd">            [(2, 3)]</span>
<span class="sd">            [(2, 4)]</span>
<span class="sd">            [(2, 5)]</span>
<span class="sd">            [(1, 0), (1, 0), (1, 0)]</span>
<span class="sd">            [(3, 1)]</span>
<span class="sd">            [(3, 2)]</span>
<span class="sd">            [(3, 3)]</span>
<span class="sd">            [(3, 4)]</span>
<span class="sd">            [(3, 5)]</span>
<span class="sd">            [(1, 0), (1, 0), (1, 0), (1, 0)]</span>
<span class="sd">            [(1, 0), (3, 1)]</span>
<span class="sd">            [(4, 2)]</span>
<span class="sd">            [(4, 3)]</span>
<span class="sd">            [(4, 4)]</span>
<span class="sd">            [(4, 5)]</span>
<span class="sd">            [(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]</span>
<span class="sd">            [(1, 0), (1, 0), (3, 1)]</span>
<span class="sd">            [(5, 2)]</span>
<span class="sd">            [(5, 3)]</span>
<span class="sd">            [(5, 4)]</span>
<span class="sd">            [(5, 5)]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_generic_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_decomposition</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_decomposition</span><span class="p">(</span>
                    <span class="n">d</span> <span class="o">-</span> <span class="n">e</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span></div>


<div class="viewcode-block" id="Quiver.dimension_nullcone">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.dimension_nullcone">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension_nullcone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dimension of the nullcone</span>

<span class="sd">        The nullcone is the set of all nilpotent representations.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``d`` -- dimension vector</span>

<span class="sd">        OUTPUT: dimension of the nullcone</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The usual example of the 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: Q.dimension_nullcone([2, 3])</span>
<span class="sd">            18</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_acyclic</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="Quiver.first_hochschild_cohomology">
<a class="viewcode-back" href="../../index.html#quiver.Quiver.first_hochschild_cohomology">[docs]</a>
    <span class="k">def</span> <span class="nf">first_hochschild_cohomology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the dimension of the first Hochschild cohomology</span>

<span class="sd">        This uses the formula of Happel from Proposition 1.6 in [MR1035222].</span>
<span class="sd">        One needs the quiver to be acyclic for this.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The first Hochschild cohomology of the `m`-th generalized Kronecker quiver</span>
<span class="sd">        is the dimension of :math:`\mathrm{PGL}_{m+1}`::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: GeneralizedKroneckerQuiver(3).first_hochschild_cohomology()</span>
<span class="sd">            8</span>

<span class="sd">        The first Hochschild cohomology vanishes if and only if the quiver is a tree::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: SubspaceQuiver(7).first_hochschild_cohomology()</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_acyclic</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
            <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">use_multiedges</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span></div>
</div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=f8c80a57"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>