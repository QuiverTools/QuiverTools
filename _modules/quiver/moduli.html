
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>quiver.moduli &#8212; QuiverTools v1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=7d3b92e0"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/quiver/moduli';</script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
<script defer data-domain="quiver.tools" src="https://plausible.io/js/script.js"></script>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="QuiverTools v1 documentation - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="QuiverTools v1 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for quiver.moduli</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations_with_replacement</span><span class="p">,</span> <span class="n">product</span>

<span class="kn">from</span> <span class="nn">sage.arith.misc</span> <span class="kn">import</span> <span class="n">bernoulli</span><span class="p">,</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">xgcd</span>
<span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partitions</span>
<span class="kn">from</span> <span class="nn">sage.combinat.permutation</span> <span class="kn">import</span> <span class="n">Permutations</span>
<span class="kn">from</span> <span class="nn">sage.combinat.schubert_polynomial</span> <span class="kn">import</span> <span class="n">SchubertPolynomialRing</span>
<span class="kn">from</span> <span class="nn">sage.combinat.sf.sf</span> <span class="kn">import</span> <span class="n">SymmetricFunctions</span>
<span class="kn">from</span> <span class="nn">sage.combinat.tuple</span> <span class="kn">import</span> <span class="n">UnorderedTuples</span>
<span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="kn">from</span> <span class="nn">sage.misc.misc_c</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span><span class="p">,</span> <span class="n">zero_vector</span>
<span class="kn">from</span> <span class="nn">sage.rings.function_field.constructor</span> <span class="kn">import</span> <span class="n">FunctionField</span>
<span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>
<span class="kn">from</span> <span class="nn">sage.rings.polynomial.polynomial_ring_constructor</span> <span class="kn">import</span> <span class="n">PolynomialRing</span>
<span class="kn">from</span> <span class="nn">sage.rings.polynomial.term_order</span> <span class="kn">import</span> <span class="n">TermOrder</span>
<span class="kn">from</span> <span class="nn">sage.rings.quotient_ring</span> <span class="kn">import</span> <span class="n">QuotientRing</span>
<span class="kn">from</span> <span class="nn">sage.rings.rational_field</span> <span class="kn">import</span> <span class="n">QQ</span>
<span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">Element</span>

<span class="kn">from</span> <span class="nn">quiver</span> <span class="kn">import</span> <span class="n">Quiver</span>

<span class="sd">&quot;&quot;&quot;Defines how permutations are multiplied.&quot;&quot;&quot;</span>
<span class="n">Permutations</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="s2">&quot;r2l&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="QuiverModuli">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuli</span><span class="p">(</span><span class="n">Element</span><span class="p">):</span>
<div class="viewcode-block" id="QuiverModuli.__init__">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for an abstract quiver moduli space.</span>

<span class="sd">        This base class contains everything that is common between</span>
<span class="sd">        - quiver moduli spaces, i.e., varieties</span>
<span class="sd">        - quiver moduli stacks</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``Q`` -- quiver</span>

<span class="sd">        - ``d`` --- dimension vector</span>

<span class="sd">        - ``theta`` -- stability parameter (default: canonical stability parameter)</span>

<span class="sd">        - ``denom`` -- denominator for slope stability (default: ``sum``), needs to be</span>
<span class="sd">          effective on the simple roots</span>

<span class="sd">        - ``condition`` -- whether to include all semistables, or only stables</span>
<span class="sd">          (default: &quot;semistable&quot;)</span>

<span class="sd">        See :class:`QuiverModuliSpace` and :class:`QuiverModuliStack` for more details.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        We can instantiate an abstract quiver moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X</span>
<span class="sd">            abstract moduli of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        It has functionality common to both varieties and stacks, i.e., when it really</span>
<span class="sd">        concerns something involving the representation variety::</span>

<span class="sd">            sage: X.all_harder_narasimhan_types()</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>

<span class="sd">        But things like dimension depend on whether we consider it as a variety or as</span>
<span class="sd">        a stack, and thus these are not implemented::</span>

<span class="sd">            sage: X.dimension()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="s2">&quot;``d`` needs to be a dimension vector&quot;</span>
        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">_is_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="s2">&quot;`theta` needs to be a stability parameter&quot;</span>
        <span class="k">assert</span> <span class="n">condition</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="s2">&quot;semistable&quot;</span><span class="p">,</span>
            <span class="s2">&quot;stable&quot;</span><span class="p">,</span>
        <span class="p">],</span> <span class="s2">&quot;condition needs to be (semi)stable&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">denom</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">simple_root</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="p">),</span> <span class="s2">&quot;denominator needs to be effective&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="s2">&quot;for the moment we require that `theta(d) == 0`&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span> <span class="o">=</span> <span class="n">Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span> <span class="o">=</span> <span class="n">denom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">=</span> <span class="n">condition</span></div>


    <span class="k">def</span> <span class="nf">__repr_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard format for shorthand string presentation.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space with non-standard description::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: print(X._QuiverModuli__repr_helper(&quot;Kronecker moduli space&quot;))</span>
<span class="sd">            Kronecker moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> representations, with&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Q = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">- d = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">- θ = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">repr</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for an abstract quiver moduli space.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuli(Q, (2, 3))</span>
<span class="sd">            abstract moduli of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__repr_helper</span><span class="p">(</span><span class="s2">&quot;abstract moduli&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuli.repr">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.repr">[docs]</a>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for an abstract quiver moduli space.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuli(Q, (2, 3))</span>
<span class="sd">            abstract moduli of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuli.to_space">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.to_space">[docs]</a>
    <span class="k">def</span> <span class="nf">to_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make the abstract quiver moduli a variety.</span>

<span class="sd">        This is an explicit way of casting an abstract :class:`QuiverModuli`</span>
<span class="sd">        to a :class:`QuiverModuliSpace`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        From an abstract quiver moduli to a space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X.to_space()</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        From a stack to a space::</span>

<span class="sd">            sage: X = QuiverModuliStack(Q, (2, 3))</span>
<span class="sd">            sage: X.to_space()</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuiverModuliSpace</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.to_stack">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.to_stack">[docs]</a>
    <span class="k">def</span> <span class="nf">to_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make the abstract quiver moduli a stack.</span>

<span class="sd">        This is an explicit way of casting an abstract :class:`QuiverModuli`</span>
<span class="sd">        to a :class:`QuiverModuliStack`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        From an abstract quiver moduli to a stack::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X.to_stack()</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        From a space to a stack::</span>

<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.to_stack()</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuiverModuliStack</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.quiver">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.quiver">[docs]</a>
    <span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the quiver of the moduli space.</span>

<span class="sd">        OUTPUT: the underlying quiver as an instance of the :class:`Quiver` class</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The quiver of a Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: Q == X.quiver()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span></div>


<div class="viewcode-block" id="QuiverModuli.dimension_vector">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.dimension_vector">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dimension vector of the moduli space.</span>

<span class="sd">        OUTPUT: the dimension vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The dimension vector of a Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X.dimension_vector()</span>
<span class="sd">            (2, 3)</span>

<span class="sd">        The dimension vector is stored in the same format as it was given::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: X = QuiverModuli(Q, {&quot;foo&quot;: 2, &quot;bar&quot;: 3})</span>
<span class="sd">            sage: X.dimension_vector()</span>
<span class="sd">            {&#39;bar&#39;: 3, &#39;foo&#39;: 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span></div>


<div class="viewcode-block" id="QuiverModuli.stability_parameter">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.stability_parameter">[docs]</a>
    <span class="k">def</span> <span class="nf">stability_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the stability parameter of the moduli space.</span>

<span class="sd">        OUTPUT: the stability parameter</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The stability parameter of a Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3), (3, -2))</span>
<span class="sd">            sage: X.stability_parameter()</span>
<span class="sd">            (3, -2)</span>

<span class="sd">        The stability parameter is stored in the same format as it was given::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: d, theta = {&quot;foo&quot;: 2, &quot;bar&quot;: 3}, {&quot;foo&quot;: 3, &quot;bar&quot;: -2}</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta);</span>
<span class="sd">            sage: X.stability_parameter()</span>
<span class="sd">            {&#39;bar&#39;: -2, &#39;foo&#39;: 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span></div>


<div class="viewcode-block" id="QuiverModuli.denominator">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.denominator">[docs]</a>
    <span class="k">def</span> <span class="nf">denominator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the denominator of the slope function :math:`\mu_{\theta}`.</span>

<span class="sd">        OUTPUT: the denominator as a function</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.denominator()</span>
<span class="sd">            &lt;built-in function sum&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span></div>


<div class="viewcode-block" id="QuiverModuli.is_nonempty">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_nonempty">[docs]</a>
    <span class="k">def</span> <span class="nf">is_nonempty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the moduli space is nonempty.</span>

<span class="sd">        OUTPUT: whether there exist stable/semistable representations, according</span>
<span class="sd">        to the condition</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver for `d = (2, 3)` has stable representations::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), (2, 3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, condition=&quot;stable&quot;); X.is_nonempty()</span>
<span class="sd">            True</span>

<span class="sd">        The Jordan quiver does not have stable representations, but it has semistable</span>
<span class="sd">        ones::</span>

<span class="sd">            sage: Q = JordanQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.is_nonempty()</span>
<span class="sd">            False</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.is_nonempty()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.is_theta_coprime">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_theta_coprime">[docs]</a>
    <span class="k">def</span> <span class="nf">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the combination of `d` and `theta` is coprime.</span>

<span class="sd">        This just calls :meth:`Quiver.is_theta_coprime` for the data defining the</span>
<span class="sd">        moduli space.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A coprime example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3)).is_theta_coprime()</span>
<span class="sd">            True</span>

<span class="sd">        And a non-example:</span>

<span class="sd">            sage: QuiverModuliSpace(Q, (3, 3)).is_theta_coprime()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Harder--Narasimhan stratification</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.all_harder_narasimhan_types">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_harder_narasimhan_types">[docs]</a>
    <span class="k">def</span> <span class="nf">all_harder_narasimhan_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all Harder--Narasimhan types.</span>

<span class="sd">        A Harder--Narasimhan (HN) type of `d` with respect to :math:`\theta`</span>
<span class="sd">        is a sequence :math:`{\bf d}^* = ({\bf d}^1,...,{\bf d}^s)` of dimension vectors</span>
<span class="sd">        such that</span>

<span class="sd">        - :math:`{\bf d}^1 + ... + {\bf d}^s = {\bf d}`</span>
<span class="sd">        - :math:`\mu_{\theta}({\bf d}^1) &gt; ... &gt; \mu_{\theta}({\bf d}^s)`</span>
<span class="sd">        - Every :math:`{\bf d}^k` is :math:`\theta`-semistable.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``proper`` -- (default: False) whether to exclude the HN-type corresponding</span>
<span class="sd">          to the stable locus</span>

<span class="sd">        - ``sorted`` -- (default: False) whether to sort the HN-types according to the</span>
<span class="sd">          given slope</span>

<span class="sd">        OUTPUT: list of tuples of dimension vectors encoding HN-types</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.all_harder_narasimhan_types()</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>
<span class="sd">            sage: X.all_harder_narasimhan_types(proper=True)</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1))]</span>
<span class="sd">            sage: d = (2, 3)</span>
<span class="sd">            sage: theta = -Q.canonical_stability_parameter(d)</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: Y.all_harder_narasimhan_types()</span>
<span class="sd">            [((0, 3), (2, 0))]</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(2, 3, 4)</span>
<span class="sd">            sage: Z = QuiverModuliSpace(Q, (2, 3, 2))</span>
<span class="sd">            sage: Z.all_harder_narasimhan_types()</span>
<span class="sd">            [((0, 1, 0), (1, 2, 1), (1, 0, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 2, 2)),</span>
<span class="sd">             ((0, 2, 0), (1, 1, 1), (1, 0, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 1, 2)),</span>
<span class="sd">             ((0, 3, 0), (2, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 3, 0), (2, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 2, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 1), (1, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 1, 0), (0, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 3, 2)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 1, 0), (0, 2, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 2, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 1, 0), (1, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 2)),</span>
<span class="sd">             ((1, 2, 0), (0, 1, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 2, 0), (0, 1, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 2, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 2, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 2, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 2, 1), (1, 1, 1)),</span>
<span class="sd">             ((1, 3, 1), (1, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 2)),</span>
<span class="sd">             ((2, 0, 1), (0, 3, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 1, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((2, 1, 1), (0, 2, 1)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((2, 3, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 3, 2),)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>

        <span class="n">all_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_all_harder_narasimhan_types</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="nb">sorted</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">proper</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d</span><span class="p">,)</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
            <span class="n">all_types</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">all_types</span></div>


<div class="viewcode-block" id="QuiverModuli.is_harder_narasimhan_type">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_harder_narasimhan_type">[docs]</a>
    <span class="k">def</span> <span class="nf">is_harder_narasimhan_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if ``dstar`` is a Harder--Narasimhan type.</span>

<span class="sd">        A Harder--Narasimhan (HN) type of `d` with respect to :math:`\theta`</span>
<span class="sd">        is a sequence :math:`{\bf d}^* = ({\bf d}^1,...,{\bf d}^s)` of dimension vectors</span>
<span class="sd">        such that</span>

<span class="sd">        - :math:`{\bf d}^1 + ... + {\bf d}^s = {\bf d}`</span>
<span class="sd">        - :math:`\mu_{\theta}({\bf d}^1) &gt; ... &gt; \mu_{\theta}({\bf d}^s)`</span>
<span class="sd">        - Every :math:`{\bf d}^k` is :math:`\theta`-semistable.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``dstar`` -- list of dimension vectors</span>

<span class="sd">        OUTPUT: whether ``dstar`` is a valid HN type for the moduli space</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: HNs = X.all_harder_narasimhan_types()</span>
<span class="sd">            sage: all(X.is_harder_narasimhan_type(dstar) for dstar in HNs)</span>
<span class="sd">            True</span>
<span class="sd">            sage: dstar = [(1, 0), (1, 0), (0, 3)]</span>
<span class="sd">            sage: X.is_harder_narasimhan_type(dstar)</span>
<span class="sd">            False</span>
<span class="sd">            sage: X.is_harder_narasimhan_type([Q.zero_vector()])</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dstar</span>
        <span class="p">),</span> <span class="s2">&quot;elements of ``dstar`` need to be dimension vectors&quot;</span>

        <span class="n">dstar</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">di</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">di</span><span class="p">),</span> <span class="n">dstar</span><span class="p">))</span>

        <span class="c1"># first condition: sum to dimension vector</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dstar</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># second condition: decreasing slopes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="o">&gt;</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># third condition</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dstar</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="QuiverModuli.codimension_of_harder_narasimhan_stratum">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_of_harder_narasimhan_stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of the HN stratum of ``dstar``</span>
<span class="sd">        inside the representation variety :math:`R(Q,d)`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``dstar`` -- the HN type as a list of dimension vectors</span>

<span class="sd">        - ``secure`` -- whether to first check it is an HN-type (default: False)</span>

<span class="sd">        OUTPUT: codimension as an integer</span>

<span class="sd">        By default, the method does not check if ``dstar`` is a valid HN type.</span>
<span class="sd">        This can be enabled by passing ``secure=True``.</span>

<span class="sd">        The codimension of the HN stratum of :math:`d^* = (d^1,...,d^s)` is given by</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            - \sum_{k &lt; l} \langle {\bf d}^k,{\bf d}^l\rangle</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``dstar`` -- list of dimension vectors</span>

<span class="sd">        - ``secure`` -- whether to check ``dstar`` is an HN-type (default: False)</span>

<span class="sd">        OUTPUT: codimension of the HN-stratum</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: HNs = X.all_harder_narasimhan_types()</span>
<span class="sd">            sage: [X.codimension_of_harder_narasimhan_stratum(dstar) for dstar in HNs]</span>
<span class="sd">            [12, 9, 8, 3, 18, 10, 4, 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dstar</span>
        <span class="p">),</span> <span class="s2">&quot;elements of ``dstar`` need to be dimension vectors&quot;</span>

        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_harder_narasimhan_type</span><span class="p">(</span><span class="n">dstar</span><span class="p">),</span> <span class="s2">&quot;``dstar`` must be HN-type&quot;</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dstar</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">))</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.codimension_unstable_locus">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_unstable_locus">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_unstable_locus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes codimension of the unstable locus inside the representation variety.</span>

<span class="sd">        This is the minimum of the codimensions of the proper Harder--Narasimhan strata</span>
<span class="sd">        of the representation variety.</span>

<span class="sd">        OUTPUT: codimension of the unstable locus</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            3</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: Q = ThreeVertexQuiver(1, 6, 1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (1, 6, 6))</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            1</span>

<span class="sd">        The :math:`\mathrm{A}_2` quiver is of finite type::</span>

<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># note that while the HN types and strata depend on the denominator</span>
        <span class="c1"># the maximum of their codimensions does not</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dstar</span> <span class="ow">in</span> <span class="n">HNs</span>
        <span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Luna</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.all_luna_types">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_luna_types">[docs]</a>
    <span class="k">def</span> <span class="nf">all_luna_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_stable</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the unordered list of all Luna types of ``d`` for ``theta``.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``exclude_stable`` -- whether to exclude the stable Luna type ``{d: [1]}``</span>
<span class="sd">          (default: False)</span>

<span class="sd">        OUTPUT: the list of all the Luna types as dictionaries.</span>

<span class="sd">        The Luna stratification of the representation variety concerns the étale-local</span>
<span class="sd">        structure of the moduli space of semistable quiver representations. It is</span>
<span class="sd">        studied in MR1972892_, and for more details one is referred there.</span>

<span class="sd">        .. _MR1972892: https://mathscinet.ams.org/mathscinet/relay-station?mr=1972892</span>

<span class="sd">        A Luna type of :math:`{\bf d}` for :math:`\theta` is an unordered sequence</span>
<span class="sd">        :math:`(({\bf d}^1,m_1),...,({\bf d}^s,m_s))` of couples of dimension vectors</span>
<span class="sd">        :math:`{\bf d}^k` and positive integers :math:`m_k` such that</span>

<span class="sd">        - :math:`m_1{\bf d}^1 + ... + m_s{\bf d}^s = {\bf d}`,</span>
<span class="sd">        - :math:`\mu_{\theta}({\bf d}^k) = \mu_{\theta}({\bf d})`, and</span>
<span class="sd">        - all the :math:`{\bf d}^k` admit a :math:`\theta`-stable representation.</span>

<span class="sd">        Note that a couple :math:`({\bf d}^i, m_i)`</span>
<span class="sd">        can appear multiple times in a Luna type, and the same dimension vector</span>
<span class="sd">        :math:`{\bf d}^i` can appear coupled with different integers.</span>

<span class="sd">        IMPLEMENTATION:</span>

<span class="sd">        Here a Luna type is a dictionary</span>
<span class="sd">        ``{d^1: p^1, ... d^s: p^s}``</span>
<span class="sd">        whose keys are dimension vectors :math:`{\bf d}^k` and values are non-empty</span>
<span class="sd">        lists of positive integers</span>
<span class="sd">        ``p^k = [p_{k, 1}, ..., p_{k, t_k}]``.</span>

<span class="sd">        The corresponding Luna type is then the unordered sequence of tuples</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            ({\bf d}^1, p_{1, 1}), \dots, ({\bf d}^1, p_{1, t_1}), \dots</span>
<span class="sd">            ({\bf d}^s, p_{s, 1}), \dots, ({\bf d}^s, p_{s, t_s}),</span>

<span class="sd">        such that</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            (p_{1, 1} + \dots + p_{1, t_1}) \cdot {\bf d}^1 + \dots +</span>
<span class="sd">            (p_{s, 1} + \dots + p_{s, t_s}) \cdot {\bf d}^s = {\bf d}.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        The way we compute the Luna types of a quiver moduli space is taken from</span>
<span class="sd">        Section 4 in MR2511752_.</span>

<span class="sd">        .. _MR2511752: https://mathscinet.ams.org/mathscinet/relay-station?mr=2511752</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (3, 3), (1, -1))</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(1, 1): [3]}, {(1, 1): [2, 1]}, {(1, 1): [1, 1, 1]}]</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (3, 3), (1, -1))</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(3, 3): [1]},</span>
<span class="sd">             {(1, 1): [1], (2, 2): [1]},</span>
<span class="sd">             {(1, 1): [3]},</span>
<span class="sd">             {(1, 1): [2, 1]},</span>
<span class="sd">             {(1, 1): [1, 1, 1]}]</span>

<span class="sd">        The zero vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (0, 0), (1, -1))</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(0, 0): [1]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="c1"># Q.zero_vector() can&#39;t be hashed a priori</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">())</span>
            <span class="k">return</span> <span class="p">[{</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}]</span>

        <span class="c1"># we will build all possible Luna types from the bottom up</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># start with all subdimension vectors</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># look for subdimension vectors with the same slope as ``d``</span>
        <span class="c1"># and which admit a stable representation:</span>
        <span class="c1"># this encodes the second and third condition in the definition</span>
        <span class="n">same_slope</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
            <span class="n">ds</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">same_slope</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">same_slope</span><span class="p">)</span>

        <span class="c1"># bounds how long a Luna type can be</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">same_slope</span><span class="p">))</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">same_slope</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="c1"># first condition is not satisfied</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># from tau we build all possible Luna types</span>
                <span class="n">partial</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">taui</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tau</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">taui</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">partial</span><span class="p">[</span><span class="n">taui</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">partial</span><span class="p">[</span><span class="n">taui</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># partial has the form</span>
                <span class="c1"># {d^1: Partitions(p^1), ..., d^s: Partitions(p^s)}</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">partial</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

                <span class="c1"># we add all possible Luna types we can build to our list</span>
                <span class="n">Ls</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">values</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">partial</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="p">]</span>

        <span class="n">stable</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">if</span> <span class="n">exclude_stable</span> <span class="ow">and</span> <span class="n">stable</span> <span class="ow">in</span> <span class="n">Ls</span><span class="p">:</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">stable</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ls</span></div>


<div class="viewcode-block" id="QuiverModuli.is_luna_type">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_luna_type">[docs]</a>
    <span class="k">def</span> <span class="nf">is_luna_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if ``tau`` is a Luna type.</span>

<span class="sd">        A Luna type of :math:`{\bf d}` for :math:`\theta` is an unordered sequence</span>
<span class="sd">        :math:`(({\bf d}^1,m_1),...,({\bf d}^s,m_s))` of dimension vectors</span>
<span class="sd">        :math:`{\bf d}^k` and positive integers :math:`m_k` such that</span>

<span class="sd">        - :math:`m_1{\bf d}^1 + ... + m_s{\bf d}^s = {\bf d}`</span>
<span class="sd">        - :math:`\mu_{\theta}({\bf d}^k) = \mu_{\theta}({\bf d})`</span>
<span class="sd">        - All :math:`{\bf d}^k` admit a :math:`\theta`-stable representation</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- Luna type encoded by a dictionary of multiplicities indexed by</span>
<span class="sd">          dimension vectors</span>

<span class="sd">        OUTPUT: whether ``tau`` is a Luna type</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (3, 3), (1, -1))</span>
<span class="sd">            sage: Ls = X.all_luna_types()</span>
<span class="sd">            sage: all(X.is_luna_type(tau) for tau in Ls)</span>
<span class="sd">            True</span>

<span class="sd">        The 3-Kronecker quiver with zero vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (0, 0), (1, -1))</span>
<span class="sd">            sage: X.is_luna_type({Q.zero_vector(): [1]})</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">dk</span><span class="p">)</span> <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">),</span> <span class="s2">&quot;elements of ``tau`` need to be dimension vectors&quot;</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="c1"># Q.zero_vector() can&#39;t be hashed a priori</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">tau</span> <span class="o">==</span> <span class="p">{</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>

        <span class="c1"># we check the 3 conditions in that order</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">dk</span> <span class="k">for</span> <span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.dimension_of_luna_stratum">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.dimension_of_luna_stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension_of_luna_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the Luna stratum :math:`S_\tau`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- Luna type encoded by a dictionary of multiplicities indexed by</span>
<span class="sd">          dimension vectors</span>

<span class="sd">        - ``secure`` -- whether to first check it is a Luna type (default: False)</span>

<span class="sd">        OUTPUT: dimension of the corresponding Luna stratum</span>

<span class="sd">        The dimension of the Luna stratum of ``tau = {d^1: p^1,...,d^s: p^s}`` is</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \sum_k l(p^k)(1 - \langle {\bf d}^k,{\bf d}^k\rangle)</span>

<span class="sd">        where for a partition :math:`p = (n_1,...,n_l)`,</span>
<span class="sd">        the length `l(p)` is `l`, i.e., the number of summands.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 2), (1, -1))</span>
<span class="sd">            sage: Ls = X.all_luna_types(); Ls</span>
<span class="sd">            [{(1, 1): [2]}, {(1, 1): [1, 1]}]</span>
<span class="sd">            sage: [X.dimension_of_luna_stratum(tau) for tau in Ls]</span>
<span class="sd">            [1, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_luna_type</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="s2">&quot;``tau`` needs to be a Luna type&quot;</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">di</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">di</span><span class="p">))</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="QuiverModuli.local_quiver_setting">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.local_quiver_setting">[docs]</a>
    <span class="k">def</span> <span class="nf">local_quiver_setting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local quiver and dimension vector for the given Luna type.</span>

<span class="sd">        The local quiver describes the singularities of a moduli space,</span>
<span class="sd">        and is introduced and studied in studied in MR1972892_.</span>

<span class="sd">        .. _MR1972892: https://mathscinet.ams.org/mathscinet/relay-station?mr=1972892</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- Luna type encoded by a dictionary of multiplicities indexed by</span>
<span class="sd">          dimension vectors</span>

<span class="sd">        - ``secure`` -- whether to first check it is a Luna type (default: False)</span>

<span class="sd">        OUTPUT: tuple consisting of a Quiver object and a dimension vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 2), (1, -1))</span>
<span class="sd">            sage: Ls = X.all_luna_types(); Ls</span>
<span class="sd">            [{(2, 2): [1]}, {(1, 1): [2]}, {(1, 1): [1, 1]}]</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(Ls[0]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix(), dloc</span>
<span class="sd">            ([4], (1))</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(Ls[1]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix(), dloc</span>
<span class="sd">            ([1], (2))</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(Ls[2]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix(), dloc</span>
<span class="sd">            (</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [1 1], (1, 1)</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_luna_type</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="s2">&quot;``tau`` needs to be a Luna type&quot;</span>

        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="c1"># we use the order of vertices provided by ``tau.keys()`` for Qloc and dloc</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">generic_ext</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">eq</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">dp</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">Qloc</span> <span class="o">=</span> <span class="n">Quiver</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">dloc</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">m</span> <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">dp</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Qloc</span><span class="p">,</span> <span class="n">dloc</span></div>


    <span class="k">def</span> <span class="nf">_codimension_inverse_image_luna_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of the preimage of the Luna stratum</span>

<span class="sd">        This is the codimension of :math:`\pi^{-1}(S_{tau})`</span>
<span class="sd">        inside `R(Q,d)` where</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \pi\colon R(Q,d)^{\theta{\rm-sst}}\to M^{\theta{\rm-sst}}(Q,d)</span>

<span class="sd">        is the semistable quotient map.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- Luna type encoded by a dictionary of multiplicities indexed by</span>
<span class="sd">          dimension vectors</span>

<span class="sd">        OUTPUT: the codimension of the inverse image of the Luna stratum</span>

<span class="sd">        For ``tau = {d^1: p^1,...,d^s: p^s}``</span>
<span class="sd">        the codimension of :math:`\pi^{-1}(S_{tau})` is</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            -\langle {\bf d},{\bf d} \rangle + \sum_{k=1}^s</span>
<span class="sd">            (\langle {\bf d}^k,{\bf d}^k\rangle - l(p^k) + ||p^k||^2) -</span>
<span class="sd">            \dim N(Q_{tau}, {\mathbf{d}_{tau}),</span>

<span class="sd">        where for a partition :math:`p = (n_1,...,n_l)`, we define</span>
<span class="sd">        :math:`||p||^2 = \sum_v n_v^2`</span>
<span class="sd">        and :math:`N(Q_{tau}, d_{tau})` is the nullcone of the local quiver setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="n">Qtau</span><span class="p">,</span> <span class="n">dtau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_quiver_setting</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">nkv</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">nkv</span> <span class="ow">in</span> <span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">tau</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="o">-</span> <span class="n">Qtau</span><span class="o">.</span><span class="n">dimension_nullcone</span><span class="p">(</span><span class="n">dtau</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QuiverModuli.codimension_properly_semistable_locus">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_properly_semistable_locus">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_properly_semistable_locus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of :math:`R^{\theta\rm-sst}(Q,d)</span>
<span class="sd">        \setminus R^{\theta-st}(Q,d)` inside :math:`R(Q,d)`.</span>

<span class="sd">        OUTPUT: codimension of the properly semistable locus</span>

<span class="sd">        The codimension of the properly semistable locus</span>
<span class="sd">        is the minimal codimension of the inverse image</span>
<span class="sd">        of the non-stable Luna strata.&quot;&quot;&quot;</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">(</span><span class="n">exclude_stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_codimension_inverse_image_luna_stratum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">Ls</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (Semi-)stability</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.semistable_equals_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.semistable_equals_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">semistable_equals_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether every semistable representation is stable</span>
<span class="sd">        for the given stability parameter.</span>

<span class="sd">        Every :math:`\theta`-semistable representation is</span>
<span class="sd">        :math:`\theta`-stable if and only if</span>
<span class="sd">        there are no Luna types other than (possibly) ``{d: [1]}``.</span>

<span class="sd">        OUTPUT: whether every theta-semistable representation is :math:`\theta`-stable</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (3, 3))</span>
<span class="sd">            sage: X.semistable_equals_stable()</span>
<span class="sd">            False</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: Y.semistable_equals_stable()</span>
<span class="sd">            True</span>

<span class="sd">        A double framed example as in our vector fields paper::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q = Q.framed_quiver((1, 0)).coframed_quiver((0, 0, 1))</span>
<span class="sd">            sage: d = (1, 2, 3, 1)</span>
<span class="sd">            sage: theta = (1, 300, -200, -1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.is_theta_coprime()</span>
<span class="sd">            False</span>
<span class="sd">            sage: X.semistable_equals_stable()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># the computation of all Luna types takes so much time</span>
        <span class="c1"># thus we should first tests if ``d`` is ``theta``-coprime</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># this is probably the fastest way as checking theta-coprimality is fast</span>
        <span class="c1"># whereas checking for existence of a semi-stable representation</span>
        <span class="c1"># is a bit slower</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">(</span><span class="n">exclude_stable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">Ls</span>  <span class="c1"># this checks if the list is empty</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ample stability</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.is_amply_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_amply_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">is_amply_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if the dimension vector is amply stable for the stability parameter</span>

<span class="sd">        By definition, a dimension vector `d` is :math:`\theta`-amply stable if the</span>
<span class="sd">        codimension of the :math:`\theta`-semistable locus</span>
<span class="sd">        inside `R(Q,d)` is at least 2.</span>

<span class="sd">        OUTPUT: whether the data for the quiver moduli space is amply stable</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3)).is_amply_stable()</span>
<span class="sd">            True</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3), [-3, 2]).is_amply_stable()</span>
<span class="sd">            False</span>

<span class="sd">        A three-vertex example from the rigidity paper::</span>

<span class="sd">            sage: Q = ThreeVertexQuiver(1, 6, 1)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [1, 6, 6]).is_amply_stable()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dstar</span> <span class="ow">in</span> <span class="n">HNs</span>
            <span class="p">)</span>
            <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.is_strongly_amply_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_strongly_amply_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">is_strongly_amply_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if the dimension vector is strongly amply stable for the stability</span>
<span class="sd">        parameter</span>

<span class="sd">        We call :math:`{\bf d}` strongly amply stable for :math:`\theta` if</span>
<span class="sd">        :math:`\langle{\bf e},{\bf d}-{\bf e}\rangle \leq -2`</span>
<span class="sd">        holds for all subdimension vectors :math:`{\bf e}` of :math:`{\bf d}` for which</span>
<span class="sd">        :math:`\mu_{\theta}({\bf e})\geq\mu_{\theta}({\bf d})`.</span>

<span class="sd">        OUTPUT: whether the data for the quiver moduli space is strongly amply stable</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3)).is_strongly_amply_stable()</span>
<span class="sd">            True</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(5, 1, 1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [4, 1, 4])</span>
<span class="sd">            sage: X.is_amply_stable()</span>
<span class="sd">            True</span>
<span class="sd">            sage: X.is_strongly_amply_stable()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># subdimension vectors of smaller slope</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
        <span class="n">es</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">slope</span><span class="p">,</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">es</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Methods related to Teleman quantization</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.harder_narasimhan_weight">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.harder_narasimhan_weight">[docs]</a>
    <span class="k">def</span> <span class="nf">harder_narasimhan_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">harder_narasimhan_type</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Teleman weight of a Harder-Narasimhan type</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``harder_narasimhan_type`` -- list of vectors of Ints</span>

<span class="sd">        OUTPUT: weight as a fraction</span>

<span class="sd">        The weight of a Harder-Narasimhan type :math:`d^*`</span>
<span class="sd">        is the weight of the associated 1-PS :math:`\lambda` acting on</span>
<span class="sd">        :math:`\det(N_{S/R})^{\vee}|_Z`, where `S` is the</span>
<span class="sd">        corresponding Harder--Narasimhan stratum.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_weight_bounds`, :meth:`if_rigidity_inequality_holds`</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: HN = X.all_harder_narasimhan_types(proper=True)</span>
<span class="sd">            sage: {dstar: X.harder_narasimhan_weight(dstar) for dstar in HN}</span>
<span class="sd">            {((1, 0), (1, 1), (0, 2)): 135,</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)): 100,</span>
<span class="sd">             ((1, 0), (1, 3)): 90,</span>
<span class="sd">             ((1, 1), (1, 2)): 15/2,</span>
<span class="sd">             ((2, 0), (0, 3)): 270,</span>
<span class="sd">             ((2, 1), (0, 2)): 100,</span>
<span class="sd">             ((2, 2), (0, 1)): 30}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span>
        <span class="n">HN</span> <span class="o">=</span> <span class="n">harder_narasimhan_type</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">HN</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HN</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">HN</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.all_weight_bounds">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_weight_bounds">[docs]</a>
    <span class="k">def</span> <span class="nf">all_weight_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all weights appearing in Teleman quantization.</span>

<span class="sd">        For each HN type, the 1-PS lambda acts on :math:`\det(N_{S/R}^{\vee}|_Z)`</span>
<span class="sd">        with a certain weight. Teleman quantization gives a numerical condition</span>
<span class="sd">        involving these weights to compute cohomology on the quotient.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``as_dict`` -- (default: False) when True it will give a dict whose keys are</span>
<span class="sd">          the HN-types and whose values are the weights</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 6-dimensional 3-Kronecker example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: X = QuiverModuliSpace(KroneckerQuiver(3), (2, 3))</span>
<span class="sd">            sage: X.all_weight_bounds()</span>
<span class="sd">            [135, 100, 90, 15/2, 270, 100, 30]</span>
<span class="sd">            sage: X.all_weight_bounds(as_dict=True)</span>
<span class="sd">            {((1, 0), (1, 1), (0, 2)): 135,</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)): 100,</span>
<span class="sd">             ((1, 0), (1, 3)): 90,</span>
<span class="sd">             ((1, 1), (1, 2)): 15/2,</span>
<span class="sd">             ((2, 0), (0, 3)): 270,</span>
<span class="sd">             ((2, 1), (0, 2)): 100,</span>
<span class="sd">             ((2, 2), (0, 1)): 30}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is only relevant on the unstable locus</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">dstar</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">harder_narasimhan_weight</span><span class="p">(</span><span class="n">dstar</span><span class="p">),</span> <span class="n">HNs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">HNs</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.if_rigidity_inequality_holds">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.if_rigidity_inequality_holds">[docs]</a>
    <span class="k">def</span> <span class="nf">if_rigidity_inequality_holds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        OUTPUT: whether the rigidity inequality holds on the given moduli</span>

<span class="sd">        If the weights of the 1-PS lambda on :math:`\det(N_{S/R}|_Z)` for each HN type</span>
<span class="sd">        are all strictly larger than the weights of the tensors of the universal bundles</span>
<span class="sd">        :math:`U_i^\vee \otimes U_j`,</span>
<span class="sd">        then the resulting moduli space is infinitesimally rigid.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Kronecker moduli satisfy the rigidity inequality::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: X = QuiverModuliSpace(KroneckerQuiver(3), (2, 3))</span>
<span class="sd">            sage: X.if_rigidity_inequality_holds()</span>
<span class="sd">            True</span>

<span class="sd">        The following 3-vertex example does not (however, it is rigid by other means)::</span>

<span class="sd">            sage: X = QuiverModuliSpace(ThreeVertexQuiver(1, 6, 1), [1, 6, 6])</span>
<span class="sd">            sage: X.if_rigidity_inequality_holds()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_weight_bounds</span><span class="p">()</span>

        <span class="c1"># we compute the maximum weight of the tensors of the universal bundles</span>
        <span class="c1"># this is only relevant on the unstable locus</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">tensor_weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">dstar</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
                <span class="n">HNs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tensor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HNs</span><span class="p">)))</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tautological relations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_all_forbidden_subdimension_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all forbidden subdimension vectors</span>

<span class="sd">        These are the dimension vectors `d&#39;` of d for which</span>

<span class="sd">        - :math:`\mu_{\theta}(d&#39;) &gt; \mu_{\theta}(d)` (in the semistable case)</span>
<span class="sd">        - or for which :math:`\mu_{\theta}(d&#39;) &gt;= \mu_{\theta}(d)` (in the stable case).</span>

<span class="sd">        OUTPUT: list of forbidden subdimension vectors vectors</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X._all_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2)]</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X._all_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="p">,</span> <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">es</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">slope</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">slope</span><span class="p">,</span> <span class="n">es</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">slope</span><span class="p">,</span> <span class="n">es</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_all_minimal_forbidden_subdimension_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all `minimal` forbidden subdimension vectors</span>

<span class="sd">        Minimality is with respect to the partial order `e &lt;&lt; d` which means</span>
<span class="sd">        :math:`e_i \leq d_i` for every source `i`, :math:`e_j \geq d_j`</span>
<span class="sd">        for every sink `j`, and :math:`e_k = d_k` for every vertex which is neither</span>
<span class="sd">        a source nor a sink. See also :meth:`Quiver.division_order`.</span>

<span class="sd">        OUTPUT: list of minimal forbidden dimension vectors</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X._all_minimal_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (2, 1), (3, 2)]</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: Y._all_minimal_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 1), (2, 2)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="n">forbidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_forbidden_subdimension_vectors</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">is_minimal</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">division_order</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">e</span><span class="p">,</span> <span class="n">forbidden</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_minimal</span><span class="p">,</span> <span class="n">forbidden</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__tautological_presentation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tautological presentation of the Chow ring of the moduli space.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``inRoots`` -- (default: False) whether to return the relations in Chern roots</span>
<span class="sd">        - ``chernClasses`` -- (default: None) optional list of strings to name the Chern classes</span>
<span class="sd">        - ``chernRoots`` -- (default: None) optional list of strings to name the Chern roots</span>

<span class="sd">        OUTPUT: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">chernRoots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernRoots</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;t</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">chernRoots</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns generator(R, i, r) = t{i+1}_{r+1}.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]))</span>

<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generators of the tautological ideal regarded upstairs, i.e. in A*([R/T]).</span>
<span class="sd">        For a forbidden subdimension vector e of d, the forbidden polynomial in Chern</span>
<span class="sd">        roots is given by :math:`\prod_{a: i \to j} \prod_{r=1}^{e_i}</span>
<span class="sd">        \prod_{s=e_j+1}^{d_j} (tj_s - ti_r) =</span>
<span class="sd">        \prod_{i,j} \prod_{r=1}^{e_i} \prod_{s=e_j+1}^{d_j} (tj_s - ti_r)^{a_{ij}}.&quot;&quot;&quot;</span>
        <span class="n">forbiddenPolynomials</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="p">(</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
                            <span class="o">**</span> <span class="n">Q</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_minimal_forbidden_subdimension_vectors</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">inRoots</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;ParentRing&quot;</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
                <span class="s2">&quot;Generators&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
                <span class="s2">&quot;Relations&quot;</span><span class="p">:</span> <span class="n">forbiddenPolynomials</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;delta is the discriminant&quot;&quot;&quot;</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;longest is the longest Weyl group element</span>
<span class="sd">            when regarding W as a subgroup of S_{sum d_i}&quot;&quot;&quot;</span>
            <span class="n">longest</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">longest</span> <span class="o">=</span> <span class="n">longest</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">bruhat_smaller</span><span class="o">=</span><span class="n">longest</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">antisymmetrization</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;The antisymmetrization of f is the symmetrization</span>
<span class="sd">                divided by the discriminant.&quot;&quot;&quot;</span>

                <span class="c1"># I don&#39;t want to define W and delta here but globally because then</span>
                <span class="c1"># we need to compute it just once. That&#39;s probably a bit faster.</span>
                <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">ngens</span><span class="p">())})</span>

                <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="n">permute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">W</span><span class="p">)</span> <span class="o">//</span> <span class="n">delta</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Schubert basis of A^*([R/T]) over A^*([R/G])&quot;&quot;&quot;</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">SchubertPolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())))</span>

            <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>

            <span class="n">Bprime</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">ngens</span><span class="p">())],</span> <span class="n">R</span>
                    <span class="p">)(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">supp</span>
            <span class="p">]</span>

            <span class="c1"># TODO is this not something already implemented?</span>
            <span class="c1"># if not, explain what it does!</span>
            <span class="k">def</span> <span class="nf">product_lists</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="n">product_lists</span><span class="p">([</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="n">l</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">schubert</span> <span class="o">=</span> <span class="n">product_lists</span><span class="p">(</span><span class="n">Bprime</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Define A = A*([R/G]).&quot;&quot;&quot;</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">chernClasses</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">TermOrder</span><span class="p">(</span><span class="s2">&quot;wdegrevlex&quot;</span><span class="p">,</span> <span class="n">degrees</span><span class="p">))</span>

            <span class="n">E</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;The Chern classes of U_i on [R/G] are the elementary symmetric functions</span>
<span class="sd">            in the Chern roots ti_1,...,ti_{d_i}.&quot;&quot;&quot;</span>
            <span class="n">elementarySymmetric</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">elementarySymmetric</span> <span class="o">=</span> <span class="n">elementarySymmetric</span> <span class="o">+</span> <span class="p">[</span>
                    <span class="n">E</span><span class="p">([</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">]</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Map xi_r to the r-th elementary symmetric function</span>
<span class="sd">            in ti_1,...,ti_{d_i}.&quot;&quot;&quot;</span>
            <span class="n">inclusion</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">elementarySymmetric</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Tautological relations in Chern classes.&quot;&quot;&quot;</span>
            <span class="n">tautological</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">antisymmetrization</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">schubert</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">forbiddenPolynomials</span>
            <span class="p">]</span>
            <span class="n">tautological</span> <span class="o">=</span> <span class="p">[</span><span class="n">inclusion</span><span class="o">.</span><span class="n">inverse_image</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">tautological</span><span class="p">]</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;ParentRing&quot;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span>
                <span class="s2">&quot;Generators&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">generator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>  <span class="c1"># is this going to work?</span>
                <span class="s2">&quot;Relations&quot;</span><span class="p">:</span> <span class="n">tautological</span><span class="p">,</span>
            <span class="p">}</span>

<div class="viewcode-block" id="QuiverModuli.tautological_relations">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.tautological_relations">[docs]</a>
    <span class="k">def</span> <span class="nf">tautological_relations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tautological relations in</span>
<span class="sd">        Chern classes (if inRoots == False) or in Chern roots.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``inRoots`` -- Bool</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>
<span class="sd">        - ``chernRoots`` -- list of Strings</span>

<span class="sd">        OUTPUT: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="n">inRoots</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="n">chernRoots</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="QuiverModuli.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dimension of the moduli space.</span>

<span class="sd">        Abstract method, see the concrete implementations for details.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`QuiverModuliSpace.dimension`,</span>
<span class="sd">            - :meth:`QuiverModuliStack.dimension`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuli.is_smooth">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the moduli space is smooth.</span>

<span class="sd">        Abstract method, see the concrete implementations for details.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`QuiverModuliSpace.is_smooth`</span>
<span class="sd">            - :meth:`QuiverModuliStack.is_smooth`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuli.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Chow ring of the moduli space.</span>

<span class="sd">        Abstract method, see the concrete implementations for details.</span>

<span class="sd">        The Chow ring of a quiver moduli space</span>

<span class="sd">        For a given datum :math:`(Q, {\bf d}, \theta)` such that</span>
<span class="sd">        `Q` is acyclic and :math:`{\bf d}` is :math:`\theta`-coprime,</span>
<span class="sd">        the Chow ring of the moduli space of quiver representations</span>
<span class="sd">        is described in MR3318266_ and arXiv.2307.01711_.</span>

<span class="sd">        Let</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            R = \bigotimes{i \in Q_0} \mathbb{Q}[x_{i, 1}, \dots, x_{i,d_i}]</span>

<span class="sd">        Let :math:`e_{i, j}` be the elementary symmetric function of degree :math:`j`</span>
<span class="sd">        in :math:`d_i` variables, and let :math:`\xi_{i, j}` be</span>
<span class="sd">        :math:`e_{i, j}(x_{i, 1},\dots,x_{i, d_i})`.</span>
<span class="sd">        We denote by :math:`A` the ring of invariants</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            A := R^{S_{\bf d}} = \mathbb{Q}[\xi_{i, j}],</span>

<span class="sd">        where :math:`S_{\bf d} = \prod_{i \in Q_0} S_{{\bf d}_i}` acts by permuting</span>
<span class="sd">        the variables.</span>

<span class="sd">        The ring :math:`\operatorname{CH}(M^{\theta-st}(Q,d))` is a quotient of `A`</span>
<span class="sd">        by two types of relations:</span>
<span class="sd">        a single linear relation, given by the choice of linearization upon which</span>
<span class="sd">        the universal bundles are constructed, and the so-called</span>
<span class="sd">        tautological relations, which we define below.</span>

<span class="sd">        The *linear relation* given by the linearization `a` is the identity</span>
<span class="sd">        :math:`\sum_{i \in Q_0} a_i c_1(U_i) = 0` in :math:`A`.</span>

<span class="sd">        A subdimension vector :math:`{\bf e}` of `:math:{\bf d}` is said to be</span>
<span class="sd">        &quot;forbidden&quot; if :math:`\mu_{\theta}({\bf e}) &gt; \mu_{\theta}({\bf d})`.</span>
<span class="sd">        One actually only needs to consider forbidden dimension vectors that are minimal</span>
<span class="sd">        with respect to a certain partial order, see :meth:`Quiver.division_order`.</span>

<span class="sd">        We define the *tautological ideal* :math:`I_{\rm taut}` of `R` as the ideal</span>
<span class="sd">        generated by the polynomials</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \prod_{a\in Q_1}\prod_{k=1}^{e_{s(a)}}</span>
<span class="sd">            \prod_{\ell=d_{t(a)}+1}^{d_{t(a)}}</span>
<span class="sd">            \left( x_{t(a),\ell}-x_{s(a),k} \right),</span>

<span class="sd">        for every forbidden subdimension vector `e` of `d`.</span>

<span class="sd">        The tautological relations in `A` are then given by the image of</span>
<span class="sd">        :math:`I_{\rm taut}` under the `antisymmetrization` map</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \rho : R \to A: \frac{1}{\delta}</span>
<span class="sd">            \sum_{\sigma \in S_{\bf d}} sign(\sigma) \sigma \cdot f,</span>

<span class="sd">        where :math:`\delta` is the discriminant</span>
<span class="sd">        :math:`\prod_{i\in Q_0}\prod_{1\leq k&lt;\ell\leq d_i}(x_{i,\ell}-x_{i,k})`.</span>

<span class="sd">        The Chow ring :math:`\operatorname{CH}(M^{\theta\rm-st}(Q,d))` is then</span>
<span class="sd">        the quotient of `A` by :math:`(\sum_{i\in Q_0} a_i c_1(U_i)) + \rho(I_{taut})`.</span>


<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Chow ring for our favourite 6-fold::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: chi = (-1, 1)</span>
<span class="sd">            sage: R = X.chow_ring(chi=chi);</span>
<span class="sd">            sage: R.ambient()</span>
<span class="sd">            Multivariate Polynomial Ring in x0_1, x0_2, x1_1, x1_2, x1_3</span>
<span class="sd">            over Rational Field</span>
<span class="sd">            sage: R</span>
<span class="sd">            Quotient of Multivariate Polynomial Ring in x0_1, x0_2, x1_1, x1_2, x1_3</span>
<span class="sd">            over Rational Field by the ideal (0, 0, 6*x0_1^3 - 12*x0_1*x0_2 -</span>
<span class="sd">            8*x0_1^2*x1_1 + 8*x0_2*x1_1 + 3*x0_1*x1_1^2 + 3*x0_1*x1_2 - 3*x1_1*x1_2 +</span>
<span class="sd">            3*x1_3, 0, 0, 0, 3*x0_1^4 - 9*x0_1^2*x0_2 + 3*x0_2^2 - 3*x0_1^3*x1_1 +</span>
<span class="sd">            6*x0_1*x0_2*x1_1 + x0_1^2*x1_1^2 - x0_2*x1_1^2 - x0_1^2*x1_2 + x0_2*x1_2 +</span>
<span class="sd">            6*x0_1*x1_3 - 3*x1_1*x1_3, 0, 0, 0, x0_1^5 - 4*x0_1^3*x0_2 +</span>
<span class="sd">            3*x0_1*x0_2^2 - 3*x0_1^3*x1_2 + 6*x0_1*x0_2*x1_2 + x0_1^2*x1_1*x1_2 -</span>
<span class="sd">            x0_2*x1_1*x1_2 + 7*x0_1^2*x1_3 - 7*x0_2*x1_3 - 3*x0_1*x1_1*x1_3, 0, 0, 0,</span>
<span class="sd">            6*x0_1^4 - 18*x0_1^2*x0_2 + 6*x0_2^2 - 8*x0_1^3*x1_1 + 16*x0_1*x0_2*x1_1 +</span>
<span class="sd">            3*x0_1^2*x1_1^2 - 3*x0_2*x1_1^2 + 3*x0_1^2*x1_2 - 3*x0_2*x1_2 -</span>
<span class="sd">            3*x0_1*x1_1*x1_2 + x1_2^2 + 3*x0_1*x1_3 - x1_1*x1_3, 0, 0, 3*x0_1^2*x0_2 +</span>
<span class="sd">            3*x0_2^2 - x0_1^3*x1_1 - 6*x0_1*x0_2*x1_1 + 3*x0_1^2*x1_1^2 +</span>
<span class="sd">            3*x0_2*x1_1^2 - 3*x0_1*x1_1^3 + x1_1^4 - 3*x0_1^2*x1_2 - 3*x0_2*x1_2 +</span>
<span class="sd">            6*x0_1*x1_1*x1_2 - 3*x1_1^2*x1_2 + x1_2^2 - 3*x0_1*x1_3 + 2*x1_1*x1_3,</span>
<span class="sd">            3*x0_1^5 - 12*x0_1^3*x0_2 + 9*x0_1*x0_2^2 - 3*x0_1^4*x1_1 +</span>
<span class="sd">            9*x0_1^2*x0_2*x1_1 - 3*x0_2^2*x1_1 + x0_1^3*x1_1^2 - 2*x0_1*x0_2*x1_1^2 -</span>
<span class="sd">            x0_1^3*x1_2 + 2*x0_1*x0_2*x1_2 + 6*x0_1^2*x1_3 - 6*x0_2*x1_3 -</span>
<span class="sd">            3*x0_1*x1_1*x1_3 + x1_2*x1_3, 0, 0, 3*x0_1*x0_2^2 - x0_1^3*x1_2 -</span>
<span class="sd">            6*x0_1*x0_2*x1_2 + 3*x0_1^2*x1_1*x1_2 + 3*x0_2*x1_1*x1_2 -</span>
<span class="sd">            3*x0_1*x1_1^2*x1_2 + x1_1^3*x1_2 + 3*x0_1*x1_2^2 - 2*x1_1*x1_2^2 -</span>
<span class="sd">            3*x0_1^2*x1_3 - 3*x0_2*x1_3 + 3*x0_1*x1_1*x1_3 - x1_1^2*x1_3 + 2*x1_2*x1_3,</span>
<span class="sd">            x0_1^6 - 5*x0_1^4*x0_2 + 6*x0_1^2*x0_2^2 - x0_2^3 - 3*x0_1^4*x1_2 +</span>
<span class="sd">            9*x0_1^2*x0_2*x1_2 - 3*x0_2^2*x1_2 + x0_1^3*x1_1*x1_2 -</span>
<span class="sd">            2*x0_1*x0_2*x1_1*x1_2 + 7*x0_1^3*x1_3 - 14*x0_1*x0_2*x1_3 -</span>
<span class="sd">            3*x0_1^2*x1_1*x1_3 + 3*x0_2*x1_1*x1_3 + x1_3^2, x0_2^3 - x0_1^3*x1_3 -</span>
<span class="sd">            6*x0_1*x0_2*x1_3 + 3*x0_1^2*x1_1*x1_3 + 3*x0_2*x1_1*x1_3 -</span>
<span class="sd">            3*x0_1*x1_1^2*x1_3 + x1_1^3*x1_3 + 3*x0_1*x1_2*x1_3 - 2*x1_1*x1_2*x1_3 +</span>
<span class="sd">            x1_3^2, -x0_1 + x1_1)</span>

<span class="sd">        .. SEEALSO:: :meth:`QuiverModuliSpace.chow_ring`</span>

<span class="sd">        .. _MR3318266: https://mathscinet.ams.org/mathscinet-getitem?mr=3318266</span>
<span class="sd">        .. _arXiv.2307.01711: https://doi.org/10.48550/arXiv.2307.01711</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="QuiverModuliSpace">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuliSpace</span><span class="p">(</span><span class="n">QuiverModuli</span><span class="p">):</span>
<div class="viewcode-block" id="QuiverModuliSpace.__init__">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor for a quiver moduli space</span>

<span class="sd">        This is the quiver moduli space as a variety.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``Q`` -- quiver</span>

<span class="sd">        - ``d`` --- dimension vector</span>

<span class="sd">        - ``theta`` -- stability parameter (default: canonical stability parameter)</span>

<span class="sd">        - ``denom`` -- denominator for slope stability (default: ``sum``), needs to be</span>
<span class="sd">          effective on the simple roots</span>

<span class="sd">        - ``condition`` -- whether to include all semistables, or only stables</span>
<span class="sd">          (default: &quot;semistable&quot;)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">QuiverModuli</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">Q</span><span class="p">,</span>
            <span class="n">d</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
            <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">,</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for the quiver moduli space</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_QuiverModuli__repr_helper</span><span class="p">(</span><span class="s2">&quot;moduli space&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliSpace.repr">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.repr">[docs]</a>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for the quiver moduli space</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the moduli space :math:`M^{\theta-(s)st}(Q,d)`.</span>

<span class="sd">        This involves several cases:</span>

<span class="sd">        - If there are :math:`\theta`-stable representations then</span>
<span class="sd">          :math:`\dim M^{\theta\rm-sst}(Q,d) =</span>
<span class="sd">          M^{\theta-st}(Q,d) = 1 - \langle d,d\rangle`;</span>
<span class="sd">        - if there are no :math:`\theta`-stable representations then</span>
<span class="sd">          :math:`\dim M^{\theta-st}(Q,d) = -\infty` by convention,</span>
<span class="sd">          and we define :math:`\dim M^{\theta\rm\rm-sst} =</span>
<span class="sd">          \mathrm{max}_{\tau} \{\dim S_{\tau}\}`,</span>
<span class="sd">          the maximum of the dimension of all Luna strata.</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        The A2-quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(2)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            1</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            1</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            2</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3), condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            6</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3],condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            10</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 3],condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 4],condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 4],condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>

<span class="sd">        The Jordan quiver::</span>

<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(1), (0,)).dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(JordanQuiver(1), (0,), condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(1), (1,)).dimension()</span>
<span class="sd">            1</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(1), (2,)).dimension()</span>
<span class="sd">            2</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(1), (3,)).dimension()</span>
<span class="sd">            3</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(1), (4,)).dimension()</span>
<span class="sd">            4</span>

<span class="sd">        Some generalized Jordan quivers::</span>

<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(2), (0,)).dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(2), (1,)).dimension()</span>
<span class="sd">            2</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(2), (2,)).dimension()</span>
<span class="sd">            5</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(2), (3,)).dimension()</span>
<span class="sd">            10</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(2), (4,)).dimension()</span>
<span class="sd">            17</span>

<span class="sd">        More generalized Jordan quivers::</span>

<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(3), (0,)).dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(3), (1,)).dimension()</span>
<span class="sd">            3</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(3), (2,)).dimension()</span>
<span class="sd">            9</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(3), (3,)).dimension()</span>
<span class="sd">            19</span>
<span class="sd">            sage: QuiverModuliSpace(JordanQuiver(3), (4,)).dimension()</span>
<span class="sd">            33</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># the zero dimension vector only has the zero representation which is semistable</span>
        <span class="c1"># but not stable</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span>

        <span class="c1"># if there are stable representations then both the stable and</span>
        <span class="c1"># the semi-stable moduli space have dimension `1-&lt;d,d&gt;`</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="c1"># stable locus is empty</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span>

        <span class="c1"># we care about the semistable locus</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="c1"># in this case the dimension is given by</span>
            <span class="c1"># the maximum of the dimensions of the Luna strata</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dimension_of_luna_stratum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="c1"># semistable locus is also empty</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.poincare_polynomial">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.poincare_polynomial">[docs]</a>
    <span class="k">def</span> <span class="nf">poincare_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Poincare polynomial of the moduli space.</span>

<span class="sd">        OUTPUT: Poincaré polynomial in the variable ``q``</span>

<span class="sd">        The Poincare polynomial is defined as</span>

<span class="sd">        .. MATH::</span>
<span class="sd">            P_X(q) = \sum_{i \geq 0} (-1)^i \dim{\rm H}^i(X;\mathbb{C}) q^{i/2}</span>

<span class="sd">        For a quiver moduli space whose dimension vector is</span>
<span class="sd">        :math:`\theta`-coprime, the odd cohomology vanishes</span>
<span class="sd">        and this is a polynomial in :math:`q`.</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        Corollary 6.9 in MR1974891_.</span>

<span class="sd">        .. _MR1974891: https://mathscinet.ams.org/mathscinet/relay-station?mr=1974891</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some Kronecker quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (1, 1))</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q + 1</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q^6 + q^5 + 3*q^4 + 3*q^3 + 3*q^2 + q + 1</span>
<span class="sd">            sage: Q = SubspaceQuiver(5)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (1, 1, 1, 1, 1, 2))</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q^2 + 5*q + 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(),</span> <span class="s2">&quot;need coprime&quot;</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">QuiverModuliStack</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">motive</span><span class="p">())</span>

        <span class="k">assert</span> <span class="n">P</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;must live in the polynomial ring&quot;</span>

        <span class="k">return</span> <span class="n">P</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.betti_numbers">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.betti_numbers">[docs]</a>
    <span class="k">def</span> <span class="nf">betti_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Betti numbers of the moduli space.</span>

<span class="sd">        OUTPUT: Betti numbers of the moduli space</span>

<span class="sd">        ALGORITHM:</span>

<span class="sd">        Corollary 6.9 in MR1974891_.</span>

<span class="sd">        .. _MR1974891: https://mathscinet.ams.org/mathscinet/relay-station?mr=1974891</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some Kronecker quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (1, 1), condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q + 1</span>
<span class="sd">            sage: X.betti_numbers()</span>
<span class="sd">            [1, 0, 1]</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3), condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.betti_numbers()</span>
<span class="sd">            [1, 0, 1, 0, 3, 0, 3, 0, 3, 0, 1, 0, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(),</span> <span class="s2">&quot;need coprime&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="c1"># p is the prime place of the DVR associated with v</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">zeros</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">ext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poincare_polynomial</span><span class="p">())</span>
        <span class="n">betti</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="n">v</span>
            <span class="n">betti</span> <span class="o">=</span> <span class="n">betti</span> <span class="o">+</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">betti</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.is_smooth">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.is_smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the moduli space is smooth.</span>

<span class="sd">        This is easy if the condition is &quot;stable&quot;, because this moduli space is always</span>
<span class="sd">        smooth. In the &quot;semistable&quot; case there is an algorithm, by combining the work</span>
<span class="sd">        of Adriaenssens--Le Bruyn and Bocklandt, which is currently not implemented.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some 3-Kronecker example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3)).is_smooth()</span>
<span class="sd">            True</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3), condition=&quot;stable&quot;).is_smooth()</span>
<span class="sd">            True</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (3, 3), condition=&quot;stable&quot;).is_smooth()</span>
<span class="sd">            True</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (3, 3)).is_smooth()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># stable locus is always smooth</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># if we have semistables, it is more subtle</span>
        <span class="c1"># this guarantees smoothness without an expensive calculation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># also guarantees smoothness</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">semistable_equals_stable</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># need to combine the local quivers from Adriaenssens--Le Bruyn</span>
        <span class="c1"># with Bocklandt&#39;s criterion for smoothness</span>
        <span class="c1"># see https://github.com/QuiverTools/QuiverTools/issues/24</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.semisimple_moduli_space">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.semisimple_moduli_space">[docs]</a>
    <span class="k">def</span> <span class="nf">semisimple_moduli_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the moduli space with `theta` replaced by zero.</span>

<span class="sd">        This is the moduli space of semisimple representations for the same quiver</span>
<span class="sd">        and the same dimension vector.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        For an acyclic quiver this moduli space is a point::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.semisimple_moduli_space().dimension()</span>
<span class="sd">            0</span>

<span class="sd">        For a quiver with oriented cycles we get an affine variety::</span>

<span class="sd">            sage: Q = JordanQuiver(2)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (3,))</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">QuiverModuliSpace</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">())</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.is_projective">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.is_projective">[docs]</a>
    <span class="k">def</span> <span class="nf">is_projective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the moduli space is projective</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        For acyclic quivers the semistable moduli space is always projective::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3)).is_projective()</span>
<span class="sd">            True</span>

<span class="sd">        If we have strictly semistable representations, then the stable moduli space</span>
<span class="sd">        is only quasiprojective but not projective::</span>

<span class="sd">            sage: QuiverModuliSpace(Q, (3, 3), condition=&quot;stable&quot;).is_projective()</span>
<span class="sd">            False</span>

<span class="sd">        In pathological cases we can have that the affine moduli space of semisimples</span>
<span class="sd">        is reduced to a point, and the projective-over-affine becomes projective::</span>

<span class="sd">            sage: Q = CyclicQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 0, 2)).is_projective()</span>
<span class="sd">            True</span>

<span class="sd">        For the zero dimension vector we get either a point or an empty space, which is</span>
<span class="sd">        always projective::</span>

<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (0, 0)).is_projective()</span>
<span class="sd">            True</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (0, 0), condition=&quot;stable&quot;).is_projective()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>

        <span class="c1"># in the acyclic case the semistable moduli space is always projective</span>
        <span class="c1"># the stable moduli space is projective if semistability is stability</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_acyclic</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">semistable_equals_stable</span><span class="p">()</span>
        <span class="c1"># so now Q has oriented cycles: the moduli space is projective-over-affine</span>
        <span class="c1"># if we have semistable, or quasiprojective-over-affine is we have stable</span>
        <span class="c1"># it suffices that the affine is just a point then</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">semisimple_moduli_space</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">semisimple_moduli_space</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">semistable_equals_stable</span><span class="p">()</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.picard_rank">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.picard_rank">[docs]</a>
    <span class="k">def</span> <span class="nf">picard_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Picard rank of the moduli space.</span>

<span class="sd">        We compute this as the Betti number :math:`\mathrm{b}_2`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Kronecker moduli are rank 1::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3)).picard_rank()</span>
<span class="sd">            1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_smooth</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_projective</span><span class="p">(),</span> <span class="s2">&quot;must be smooth and projective&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">betti_numbers</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.index">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the index of the moduli space</span>

<span class="sd">        The index is the largest integer dividing the canonical divisor in Pic.</span>
<span class="sd">        For now this is only implemented for the canonical stability condition.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The usual 3-Kronecker example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3)).index()</span>
<span class="sd">            3</span>

<span class="sd">        Subspace quiver moduli have index 1::</span>

<span class="sd">            sage: Q = SubspaceQuiver(7)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (1, 1, 1, 1, 1, 1, 1, 2)).index()</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">theta</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">()</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_amply_stable</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Chow ring of the moduli space.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``chi`` -- vector of Ints</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>

<span class="sd">        OUTPUT: ring</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q= KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (1, 1))</span>
<span class="sd">            sage: chi = (1, 0)</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1], [x1_1]]</span>


<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: chi = (-1, 1)</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1],</span>
<span class="sd">            [x1_1],</span>
<span class="sd">            [x0_2, x1_1^2, x1_2],</span>
<span class="sd">            [x1_1^3, x1_1*x1_2, x1_3],</span>
<span class="sd">            [x1_1^2*x1_2, x1_2^2, x1_1*x1_3],</span>
<span class="sd">            [x1_2*x1_3],</span>
<span class="sd">            [x1_3^2]]</span>

<span class="sd">        The 5-subspaces quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = SubspaceQuiver(5), (1, 1, 1, 1, 1, 2)</span>
<span class="sd">            sage: theta = (2, 2, 2, 2, 2, -5)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = (-1, -1, -1, -1, -1, 3)</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1], [x1_1, x2_1, x3_1, x4_1, x5_1], [x5_2]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="c1"># This implementation only works if d is theta-coprime</span>
        <span class="c1"># which implies that d is indivisible.</span>
        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="c1"># if a linearization is not given we compute one here.</span>
        <span class="k">if</span> <span class="n">chi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>

        <span class="c1"># chi must have integer entries</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">QQ</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chi</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure that chi has weight one, i.e.,</span>
<span class="sd">        provides a retraction for X*(PG) --&gt; X*(G).&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">chi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_QuiverModuli__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">rels</span> <span class="o">=</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;ParentRing&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Generators&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span>

        <span class="n">I</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">rels</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">chi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">generator</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]))</span>

        <span class="k">return</span> <span class="n">QuotientRing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.chern_class_line_bundle">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chern_class_line_bundle">[docs]</a>
    <span class="k">def</span> <span class="nf">chern_class_line_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first Chern class of the line bundle</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            L(\eta) = \bigotimes_{i \in Q_0} \det(U_i)^{-\eta_i},</span>

<span class="sd">        where :math:`\eta` is a character of :math:`PG_d`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``eta`` -- character of :math:`PG_d` as vector in :math:`\mathbb{Z}Q_0`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">([</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.chern_character_line_bundle">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chern_character_line_bundle">[docs]</a>
    <span class="k">def</span> <span class="nf">chern_character_line_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Chern character of L(eta).</span>

<span class="sd">        The Chern character of a line bundle `L` with first Chern class `x`</span>
<span class="sd">        is given by :math:`e^x = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \dots`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chern_class_line_bundle</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.total_chern_class_universal">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.total_chern_class_universal">[docs]</a>
    <span class="k">def</span> <span class="nf">total_chern_class_universal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives the total Chern class of the universal bundle U_i(chi).&quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.point_class">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.point_class">[docs]</a>
    <span class="k">def</span> <span class="nf">point_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the point class as an expression in Chern classes of the</span>
<span class="sd">        :math:`U_i` (``chi``).</span>

<span class="sd">        The point class is given as the homogeneous component of degree</span>
<span class="sd">        :math:`\dim X` of the expression</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \prod_{a \in Q_1} c(U_{t(a)})^{d_{s(a)}} / (\prod_{i \in Q_0} c(U_i)^{d_i})</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        :math:`\mathbb{P}^7` as a quiver moduli space</span>
<span class="sd">        of a generalized Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(8)</span>
<span class="sd">            sage: d = (1, 1)</span>
<span class="sd">            sage: theta = (1, -1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = (1, 0)</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;o&#39;,&#39;h&#39;])</span>
<span class="sd">            h^7</span>

<span class="sd">        Our favorite 6-fold::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: d = (2, 3)</span>
<span class="sd">            sage: theta = (3, -2)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = (-1, 1)</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;x1&#39;,&#39;x2&#39;,&#39;y1&#39;,&#39;y2&#39;,&#39;y3&#39;])</span>
<span class="sd">            y3^2</span>

<span class="sd">        A moduli space of the 5-subspaces quiver;</span>
<span class="sd">        it agrees with the blow-up of :math:`\mathbb{P}^2` in 4 points</span>
<span class="sd">        in general position::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = SubspaceQuiver(5)</span>
<span class="sd">            sage: d = (1, 1, 1, 1, 1, 2)</span>
<span class="sd">            sage: theta = (2, 2, 2, 2, 2, -5)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = (-1, -1, -1, -1, -1, 3)</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;x1&#39;,&#39;x2&#39;,&#39;x3&#39;,&#39;x4&#39;,&#39;x5&#39;,&#39;y&#39;,&#39;z&#39;])</span>
<span class="sd">            1/2*z</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="o">=</span><span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">cover</span><span class="p">()</span>  <span class="c1"># The quotient map</span>
        <span class="n">sect</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">lifting_map</span><span class="p">()</span>  <span class="c1"># A choice of a section of pi</span>

        <span class="k">if</span> <span class="n">chi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>

        <span class="n">my_numerator</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">total_chern_class_universal</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
                <span class="o">**</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">my_denom</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">total_chern_class_universal</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
                <span class="o">**</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">quotient</span> <span class="o">=</span> <span class="n">my_numerator</span> <span class="o">/</span> <span class="n">my_denom</span>

        <span class="k">return</span> <span class="n">pi</span><span class="p">(</span><span class="n">sect</span><span class="p">(</span><span class="n">quotient</span><span class="p">)</span><span class="o">.</span><span class="n">homogeneous_components</span><span class="p">()[</span><span class="n">N</span><span class="p">])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.degree">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.degree">[docs]</a>
    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the degree of the ample line bundle given by eta.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Need check for ampleness first</span>

        <span class="k">if</span> <span class="n">eta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chern_class_line_bundle</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_class</span><span class="p">(</span><span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">c</span><span class="o">**</span><span class="n">N</span> <span class="o">/</span> <span class="n">p</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.todd_class">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.todd_class">[docs]</a>
    <span class="k">def</span> <span class="nf">todd_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Todd class of `X` is the Todd class of the tangent bundle.</span>

<span class="sd">        For quiver moduli it computes as</span>

<span class="sd">        # TODO reference Chow paper</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            td(X) =</span>
<span class="sd">            (\prod_{a:i \to j \in Q_1} \prod_{p=1}^{d_j} \prod_{q=1}^{d_i} Q(t_{j,q} -</span>
<span class="sd">            t_{i,p}))/(prod_{i \in Q_0} \prod_{p,q=1}^{d_i} Q(t_{i,q} - t_{i,p}))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">todd_generating_series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            We call the series :math:`Q(t) = t/(1-e^{-t})` the Todd generating series.</span>

<span class="sd">            The function computes the terms of this series up to degree n.&quot;&quot;&quot;</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">i</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="o">^</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

        <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Takes an element in a graded ring and discards</span>
<span class="sd">            all homogeneous components of degree &gt; n&quot;&quot;&quot;</span>
            <span class="n">hom</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">homogeneous_components</span><span class="p">()</span>
            <span class="n">keyList</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hom</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">hom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">,</span> <span class="n">keyList</span><span class="p">)])</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>
</div>


    <span class="c1"># TODO: This is maybe too specific.</span>
    <span class="c1"># def diagonal(self, chi=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Computes the class of the diagonal in the Chow ring of X x X where X is the quiver moduli space.&quot;&quot;&quot;</span>
    <span class="c1">#     &quot;&quot;&quot;It is given by the homogeneous component of degree dim X = 1 - &lt;d,d&gt; of the expression c(F)/C(E), where E = bigoplus_{i in Q_0} U_i^vee boxtimes U_i and F = bigoplus_{a in Q_1} U_{s(a)}^vee boxtimes U_{t(a)} = bigoplus_{i,j in Q_0} (U_i^vee boxtimes U_j)^{a_ij}.&quot;&quot;&quot;</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     EXAMPLES</span>

    <span class="c1">#     P^2 as a quiver moduli space:</span>
    <span class="c1">#     sage: from quiver import *</span>
    <span class="c1">#     sage: Q = GeneralizedKroneckerQuiver(3)</span>
    <span class="c1">#     sage: d = vector([1,1])</span>
    <span class="c1">#     sage: theta = vector([1,-1])</span>
    <span class="c1">#     sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
    <span class="c1">#     sage: X.diagonal()</span>
    <span class="c1">#     x1_1^2 + x1_1*y1_1 + y1_1^2</span>

    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     Q, d, theta = self._Q, self._d, self._theta</span>
    <span class="c1">#     n = Q.number_of_vertices()</span>
    <span class="c1">#     N = self.dimension()</span>
    <span class="c1">#     a = Q.adjacency_matrix()</span>

    <span class="c1">#     di = self._QuiverModuli__tautological_presentation()</span>
    <span class="c1">#     A = di[&quot;Generators&quot;]</span>
    <span class="c1">#     I = di[&quot;Relations&quot;] + A.ideal(chi)</span>

    <span class="c1">#     chernClasses1 = [&#39;x%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernClasses2 = [&#39;y%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernClasses = chernClasses1+chernClasses2</span>

    <span class="c1">#     AxA = PolynomialRing(QQ,chernClasses)</span>
    <span class="c1">#     inclusion1 = A.hom(chernClasses1,AxA)</span>
    <span class="c1">#     inclusion2 = A.hom(chernClasses2,AxA)</span>
    <span class="c1">#     B = QuotientRing(AxA,inclusion1(I) + inclusion2(I),names=chernClasses)</span>

    <span class="c1">#     pi = B.cover() # The quotient map AxA --&gt; B</span>
    <span class="c1">#     sect = B.lifting_map() # A choice of a section of pi</span>

    <span class="c1">#     chernRoots1 = [&#39;t%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernRoots2 = [&#39;u%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernRoots = chernRoots1+chernRoots2</span>
    <span class="c1">#     RxR = PolynomialRing(QQ,chernRoots)</span>

    <span class="c1">#     def generatorRxR1(i,r):</span>
    <span class="c1">#         &quot;&quot;&quot;Returns generatorRxR1(i,r) = t{i+1}_{r+1}.&quot;&quot;&quot;</span>
    <span class="c1">#         return RxR.gen(r + sum([d[j] for j in range(i)]))</span>

    <span class="c1">#     def generatorRxR2(i,r):</span>
    <span class="c1">#         &quot;&quot;&quot;Returns generatorRxR2(i,r) = u{i+1}_{r+1}.&quot;&quot;&quot;</span>
    <span class="c1">#         return RxR.gen(sum([d[j] for j in range(n)]) + r + sum([d[j] for j in range(i)]))</span>

    <span class="c1">#     E = SymmetricFunctions(ZZ).e()</span>
    <span class="c1">#     elementarySymmetric1 = []</span>
    <span class="c1">#     elementarySymmetric2 = []</span>
    <span class="c1">#     for i in range(n):</span>
    <span class="c1">#         elementarySymmetric1 = elementarySymmetric1 + [E([k]).expand(d[i], alphabet=[generatorRxR1(i,r) for r in range(d[i])]) for k in range(1,d[i]+1)]</span>
    <span class="c1">#         elementarySymmetric2 = elementarySymmetric2 + [E([k]).expand(d[i], alphabet=[generatorRxR2(i,r) for r in range(d[i])]) for k in range(1,d[i]+1)]</span>
    <span class="c1">#     elementarySymmetric = elementarySymmetric1 + elementarySymmetric2</span>
    <span class="c1">#     &quot;&quot;&quot;Map xi_r to the r-th elementary symmetric function in ti_1,...,ti_{d_i} and yi_r to the same in ui_1,...,ui_{d_i}.&quot;&quot;&quot;</span>
    <span class="c1">#     inclusion = AxA.hom(elementarySymmetric, RxR)</span>

    <span class="c1">#     def total_chern_class_boxproduct(i,j):</span>
    <span class="c1">#         &quot;&quot;&quot;Computes the total Chern class of U_i^vee boxtimes U_j&quot;&quot;&quot;</span>
    <span class="c1">#         c = prod([(1-generatorRxR1(i,r)+generatorRxR2(j,s)) for r in range(d[i]) for s in range(d[j])])</span>
    <span class="c1">#         return pi(inclusion.inverse_image(c))</span>

    <span class="c1">#     numerator = prod([total_chern_class_boxproduct(i,j)**a[i,j] for i in range(n) for j in range(n)])</span>
    <span class="c1">#     denominator = prod([total_chern_class_boxproduct(i,i) for i in range(n)])</span>
    <span class="c1">#     quotient = numerator/denominator</span>

    <span class="c1">#     return pi(sect(quotient).homogeneous_components()[N])</span>


<div class="viewcode-block" id="QuiverModuliStack">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuliStack</span><span class="p">(</span><span class="n">QuiverModuli</span><span class="p">):</span>
<div class="viewcode-block" id="QuiverModuliStack.__init__">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for a quiver moduli stack.</span>

<span class="sd">        This is the quiver moduli space as a stack.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``Q`` -- quiver</span>

<span class="sd">        - ``d`` --- dimension vector</span>

<span class="sd">        - ``theta`` -- stability parameter (default: canonical stability parameter)</span>

<span class="sd">        - ``denom`` -- denominator for slope stability (default: ``sum``), needs to be</span>
<span class="sd">          effective on the simple roots</span>

<span class="sd">        - ``condition`` -- whether to include all semistables, or only stables</span>
<span class="sd">          (default: &quot;semistable&quot;)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, (2, 3))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">QuiverModuli</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;.</span>
<span class="sd">        Give a shorthand string presentation for the quiver moduli stack</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli stack::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliStack(Q, (2, 3))</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_QuiverModuli__repr_helper</span><span class="p">(</span><span class="s2">&quot;moduli stack&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliStack.repr">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.repr">[docs]</a>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for a quiver moduli stack.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli spac::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliStack(Q, (2, 3))</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliStack.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the moduli stack :math:`[R^{(s)st}/G]`.</span>

<span class="sd">        This is the dimension of a quotient stack, thus we use</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            dim [R^{{\rm (s)st}}/G] = dim R^{{\rm (s)st}} - dim G</span>

<span class="sd">        The dimension turns out to be :math:`-\langle d,d\rangle`</span>
<span class="sd">        if the (semi-)stable locus is non-empty&quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonempty</span><span class="p">():</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span></div>


<div class="viewcode-block" id="QuiverModuliStack.is_smooth">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.is_smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the stack is smooth.</span>

<span class="sd">        The stack is a quotient of a smooth variety, thus it is always smooth.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Nothing interesting to see here::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: QuiverModuliSpace(KroneckerQuiver(3), (2, 3)).is_smooth()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="QuiverModuliStack.motive">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.motive">[docs]</a>
    <span class="k">def</span> <span class="nf">motive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gives an expression for the motive of the semistable moduli stack</span>

<span class="sd">        This really lives inside an appropriate localization of K_0(Var), but it only</span>
<span class="sd">        involves the Lefschetz class.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Loop quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = LoopQuiver(0)</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, (2,), (0,))</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            1/(L^4 - L^3 - L^2 + L)</span>
<span class="sd">            sage: Q = LoopQuiver(1)</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, (2,), (0,))</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            L^3/(L^3 - L^2 - L + 1)</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, (2, 3))</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            (-L^6 - L^5 - 3*L^4 - 3*L^3 - 3*L^2 - L - 1)/(L - 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># only for semistable.</span>
        <span class="c1"># for stable, we don&#39;t know what the motive is: it&#39;s not pure in general.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span>

        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">/</span> <span class="n">prod</span><span class="p">(</span>
                <span class="n">prod</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
            <span class="p">)</span>

        <span class="c1"># start with all subdimension vectors</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># only consider those of greater slope</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">),</span> <span class="n">ds</span><span class="p">))</span>
        <span class="c1"># put zero and ``d`` back in and sort them conveniently</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span> <span class="o">+</span> <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">(),</span> <span class="n">d</span><span class="p">]</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">_deglex_key</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># Now define a matrix T of size NxN whose entry at position (i,j) is</span>
        <span class="c1"># L^&lt;e-f,e&gt;*mot(f-e) if e = I[i] is a subdimension vector of f = I[j]</span>
        <span class="c1"># and 0 otherwise</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">UnorderedTuples</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_subdimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="o">*</span> <span class="n">QuiverModuliStack</span><span class="p">(</span>
                    <span class="n">Q</span><span class="p">,</span> <span class="n">f</span> <span class="o">-</span> <span class="n">e</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">(),</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">motive</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="c1"># solve system of linear equations T*x = e_N</span>
        <span class="c1"># and extract entry 0 of the solution x.</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">zero_vector</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
        <span class="n">y</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="QuiverModuliStack.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the Chow ring of the quotient stack.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``chernClasses``: list of Strings</span>

<span class="sd">        OUTPUT: ring</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_QuiverModuli__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rels</span> <span class="o">=</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;ParentRing&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Generators&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">QuotientRing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">rels</span><span class="p">),</span> <span class="n">names</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span></div>
</div>



<span class="k">def</span> <span class="nf">extended_gcd</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the gcd and the Bezout coefficients of a list of integers.</span>

<span class="sd">    This exists for two integers but there seems to be no implementation for more.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    An example with 3 integers::</span>

<span class="sd">        sage: from quiver import *</span>
<span class="sd">        sage: extended_gcd([4, 6, 8])</span>
<span class="sd">        [2, [-1, 1, 0]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
        <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pieter Belmans, Hans Franzen, Gianni Petrella
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>