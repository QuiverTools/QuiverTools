
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>quiver.moduli &#8212; QuiverTools v1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=7d3b92e0"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/quiver/moduli';</script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
<script defer data-domain="quiver.tools" src="https://plausible.io/js/script.js"></script>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="QuiverTools v1 documentation - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="QuiverTools v1 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for quiver.moduli</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations_with_replacement</span><span class="p">,</span> <span class="n">product</span>

<span class="kn">from</span> <span class="nn">sage.arith.misc</span> <span class="kn">import</span> <span class="n">bernoulli</span><span class="p">,</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">xgcd</span>
<span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partitions</span>
<span class="kn">from</span> <span class="nn">sage.combinat.permutation</span> <span class="kn">import</span> <span class="n">Permutations</span>
<span class="kn">from</span> <span class="nn">sage.combinat.schubert_polynomial</span> <span class="kn">import</span> <span class="n">SchubertPolynomialRing</span>
<span class="kn">from</span> <span class="nn">sage.combinat.sf.sf</span> <span class="kn">import</span> <span class="n">SymmetricFunctions</span>
<span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="kn">from</span> <span class="nn">sage.misc.misc_c</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>
<span class="kn">from</span> <span class="nn">sage.rings.function_field.constructor</span> <span class="kn">import</span> <span class="n">FunctionField</span>
<span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>
<span class="kn">from</span> <span class="nn">sage.rings.polynomial.polynomial_ring_constructor</span> <span class="kn">import</span> <span class="n">PolynomialRing</span>
<span class="kn">from</span> <span class="nn">sage.rings.polynomial.term_order</span> <span class="kn">import</span> <span class="n">TermOrder</span>
<span class="kn">from</span> <span class="nn">sage.rings.quotient_ring</span> <span class="kn">import</span> <span class="n">QuotientRing</span>
<span class="kn">from</span> <span class="nn">sage.rings.rational_field</span> <span class="kn">import</span> <span class="n">QQ</span>
<span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">Element</span>

<span class="kn">from</span> <span class="nn">quiver</span> <span class="kn">import</span> <span class="n">Quiver</span>

<span class="sd">&quot;&quot;&quot;Defines how permutations are multiplied.&quot;&quot;&quot;</span>
<span class="n">Permutations</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="s2">&quot;r2l&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="QuiverModuli">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuli</span><span class="p">(</span><span class="n">Element</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for an abstract quiver moduli space.</span>

<span class="sd">        This base class contains everything that is common between</span>
<span class="sd">        - quiver moduli spaces, i.e., varieties</span>
<span class="sd">        - quiver moduli stacks</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``Q`` -- quiver</span>

<span class="sd">        - ``d`` --- dimension vector</span>

<span class="sd">        - ``theta`` -- stability parameter (default: canonical stability parameter)</span>

<span class="sd">        - ``denom`` -- denominator for slope stability (default: ``sum``), needs to be</span>
<span class="sd">          effective on the simple roots</span>

<span class="sd">        - ``condition`` -- whether to include all semistables, or only stables</span>
<span class="sd">          (default: &quot;semistable&quot;)</span>

<span class="sd">        See :class:`QuiverModuliSpace` and :class:`QuiverModuliStack` for more details.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        We can instantiate an abstract quiver moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X</span>
<span class="sd">            abstract moduli of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        It has functionality common to both varieties and stacks, i.e., when it really</span>
<span class="sd">        concerns something involving the representation variety::</span>

<span class="sd">            sage: X.all_harder_narasimhan_types()</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>

<span class="sd">        But things like dimension depend on whether we consider it as a variety or as</span>
<span class="sd">        a stack, and thus these are not implemented::</span>

<span class="sd">            sage: X.dimension()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            NotImplementedError</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="s2">&quot;`d` is not a dimension vector of `Q`&quot;</span>
        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">_is_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="s2">&quot;`theta` is not a stability parameter for `Q`&quot;</span>
        <span class="k">assert</span> <span class="n">condition</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;semistable&quot;</span><span class="p">,</span> <span class="s2">&quot;stable&quot;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">denom</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">simple_root</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="p">),</span> <span class="s2">&quot;denominator needs to be effective&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span> <span class="o">=</span> <span class="n">Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span> <span class="o">=</span> <span class="n">denom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">=</span> <span class="n">condition</span>

    <span class="k">def</span> <span class="nf">__repr_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard format for shorthand string presentation.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space with non-standard description::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: print(X._QuiverModuli__repr_helper(&quot;Kronecker moduli space&quot;))</span>
<span class="sd">            Kronecker moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> representations, with&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Q = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">- d = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">- θ = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">repr</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for an abstract quiver moduli space.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuli(Q, (2, 3))</span>
<span class="sd">            abstract moduli of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__repr_helper</span><span class="p">(</span><span class="s2">&quot;abstract moduli&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuli.repr">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.repr">[docs]</a>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for an abstract quiver moduli space.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli spac::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuli(Q, (2, 3))</span>
<span class="sd">            abstract moduli of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuli.to_space">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.to_space">[docs]</a>
    <span class="k">def</span> <span class="nf">to_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make the abstract quiver moduli a variety.</span>

<span class="sd">        This is an explicit way of casting.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        From an abstract quiver moduli to a space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X.to_space()</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        From a stack to a space::</span>

<span class="sd">            sage: X = QuiverModuliStack(Q, (2, 3))</span>
<span class="sd">            sage: X.to_space()</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">QuiverModuliSpace</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.to_stack">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.to_stack">[docs]</a>
    <span class="k">def</span> <span class="nf">to_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make the abstract quiver moduli a stack.</span>

<span class="sd">        This is an explicit way of casting.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        From an abstract quiver moduli to a stack::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X.to_stack()</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        From a space to a stack::</span>

<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.to_stack()</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuiverModuliStack</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.quiver">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.quiver">[docs]</a>
    <span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the quiver of the moduli space.</span>

<span class="sd">        OUTPUT: the underlying quiver as an instance of the Quiver class</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The quiver of a Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: Q == X.quiver()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span></div>


<div class="viewcode-block" id="QuiverModuli.dimension_vector">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.dimension_vector">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dimension vector of the moduli space.</span>

<span class="sd">        OUTPUT: the dimension vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The dimension vector of a Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3))</span>
<span class="sd">            sage: X.dimension_vector()</span>
<span class="sd">            (2, 3)</span>

<span class="sd">        The dimension vector is stored in the same format as it was given::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: X = QuiverModuli(Q, {&quot;foo&quot;: 2, &quot;bar&quot;: 3})</span>
<span class="sd">            sage: X.dimension_vector()</span>
<span class="sd">            {&#39;bar&#39;: 3, &#39;foo&#39;: 2}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span></div>


<div class="viewcode-block" id="QuiverModuli.stability_parameter">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.stability_parameter">[docs]</a>
    <span class="k">def</span> <span class="nf">stability_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the stability parameter of the moduli space.</span>

<span class="sd">        OUTPUT: the stability parameter</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The stability parameter of a Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuli(Q, (2, 3), (3, -2))</span>
<span class="sd">            sage: X.stability_parameter()</span>
<span class="sd">            (3, -2)</span>

<span class="sd">        The stability parameter is stored in the same format as it was given::</span>

<span class="sd">            sage: Q = Quiver.from_string(&quot;foo---bar&quot;, forget_labels=False)</span>
<span class="sd">            sage: d, theta = {&quot;foo&quot;: 2, &quot;bar&quot;: 3}, {&quot;foo&quot;: 3, &quot;bar&quot;: -2}</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta);</span>
<span class="sd">            sage: X.stability_parameter()</span>
<span class="sd">            {&#39;bar&#39;: -2, &#39;foo&#39;: 3}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span></div>


<div class="viewcode-block" id="QuiverModuli.denominator">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.denominator">[docs]</a>
    <span class="k">def</span> <span class="nf">denominator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the denominator of the slope function used to define the moduli space.</span>

<span class="sd">        OUTPUT: the denominator as a function</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.denominator()</span>
<span class="sd">            &lt;built-in function sum&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span></div>


<div class="viewcode-block" id="QuiverModuli.is_nonempty">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_nonempty">[docs]</a>
    <span class="k">def</span> <span class="nf">is_nonempty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the moduli space is nonempty.</span>

<span class="sd">        OUTPUT: whether there exist stable/semistable representations</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver for `d = (2, 3)` has stable representations::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), [2, 3]</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, condition=&quot;stable&quot;); X.is_nonempty()</span>
<span class="sd">            True</span>

<span class="sd">        The Jordan quiver does not have stable representations, but it has semistable</span>
<span class="sd">        ones::</span>

<span class="sd">            sage: Q = JordanQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.is_nonempty()</span>
<span class="sd">            False</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.is_nonempty()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Harder--Narasimhan stratification</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.all_harder_narasimhan_types">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_harder_narasimhan_types">[docs]</a>
    <span class="k">def</span> <span class="nf">all_harder_narasimhan_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all Harder--Narasimhan types.</span>

<span class="sd">        A Harder--Narasimhan (HN) type of :math:`d` with respect to :math:`\theta`</span>
<span class="sd">        is a sequence :math:`d^* = (d^1,...,d^s)` of dimension vectors such that</span>

<span class="sd">        - :math:`d^1 + ... + d^s = d`</span>
<span class="sd">        - :math:`\mu_{\theta}(d^1) &gt; ... &gt; \mu_{\theta}(d^s)`</span>
<span class="sd">        - Every :math:`d^k` is :math:`\theta`-semi-stable.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``proper`` -- (default: False) whether to exclude the HN-type corresponding</span>
<span class="sd">          to the stable locus</span>

<span class="sd">        - ``sorted`` -- (default: False) whether to sort the HN-types according to the</span>
<span class="sd">          given slope</span>

<span class="sd">        OUTPUT: list of tuples of dimension vectors encoding HN-types</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            sage: X.all_harder_narasimhan_types()</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>
<span class="sd">            sage: X.all_harder_narasimhan_types(proper=True)</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1))]</span>
<span class="sd">            sage: d = [2, 3]</span>
<span class="sd">            sage: theta = -Q.canonical_stability_parameter(d)</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: Y.all_harder_narasimhan_types()</span>
<span class="sd">            [((0, 3), (2, 0))]</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(2, 3, 4)</span>
<span class="sd">            sage: Z = QuiverModuliSpace(Q, (2, 3, 2))</span>
<span class="sd">            sage: Z.all_harder_narasimhan_types()</span>
<span class="sd">            [((0, 1, 0), (1, 2, 1), (1, 0, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 2, 2)),</span>
<span class="sd">             ((0, 2, 0), (1, 1, 1), (1, 0, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 1, 2)),</span>
<span class="sd">             ((0, 3, 0), (2, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 3, 0), (2, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 2, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 1), (1, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 1, 0), (0, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 3, 2)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 1, 0), (0, 2, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 2, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 1, 0), (1, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 2)),</span>
<span class="sd">             ((1, 2, 0), (0, 1, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 2, 0), (0, 1, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 2, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 2, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 2, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 2, 1), (1, 1, 1)),</span>
<span class="sd">             ((1, 3, 1), (1, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 2)),</span>
<span class="sd">             ((2, 0, 1), (0, 3, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 1, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((2, 1, 1), (0, 2, 1)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((2, 3, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 3, 2),)]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>

        <span class="n">all_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_all_harder_narasimhan_types</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="nb">sorted</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">proper</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d</span><span class="p">,)</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
            <span class="n">all_types</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">all_types</span></div>


<div class="viewcode-block" id="QuiverModuli.is_harder_narasimhan_type">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_harder_narasimhan_type">[docs]</a>
    <span class="k">def</span> <span class="nf">is_harder_narasimhan_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if ``dstar`` is a HN type.</span>

<span class="sd">        A Harder--Narasimhan (HN) type of `d` with respect to :math:`\theta`</span>
<span class="sd">        is a sequence :math:`d^* = (d^1,...,d^s)` of dimension vectors such that</span>

<span class="sd">        - :math:`d^1 + ... + d^s = d`</span>
<span class="sd">        - :math:`\mu_{\theta}(d^1) &gt; ... &gt; \mu_{\theta}(d^s)`</span>
<span class="sd">        - Every :math:`d^k` is theta-semi-stable.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``dstar`` -- list of vectors of Ints</span>

<span class="sd">        OUTPUT: statement truth value as Bool</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], [1, 0])</span>
<span class="sd">            sage: HNs = X.all_harder_narasimhan_types()</span>
<span class="sd">            sage: all(X.is_harder_narasimhan_type(dstar) for dstar in HNs)</span>
<span class="sd">            True</span>
<span class="sd">            sage: dstar = [[1, 0], [1, 0], [0, 3]]</span>
<span class="sd">            sage: X.is_harder_narasimhan_type(dstar)</span>
<span class="sd">            False</span>
<span class="sd">            sage: X.is_harder_narasimhan_type([Q.zero_vector()])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">dstar</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">di</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">di</span><span class="p">),</span> <span class="n">dstar</span><span class="p">))</span>

        <span class="c1"># first condition: sum to dimension vector</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dstar</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># second condition: decreasing slopes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="o">&gt;</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dstar</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="QuiverModuli.codimension_of_harder_narasimhan_stratum">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_of_harder_narasimhan_stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of the HN stratum of ``dstar``</span>
<span class="sd">        inside the representation variety.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``dstar`` -- list of vectors of Ints</span>
<span class="sd">        - ``secure`` -- (default: False): Bool</span>

<span class="sd">        OUTPUT: codimension as Int</span>
<span class="sd">        # TODO</span>
<span class="sd">        # It checks for dstar to be a HN type iff secure == True. This check is slow.</span>
<span class="sd">        # Be sure to be dealing with a HN type if you call it with secure == False. This is fast but yields nonsense, if dstar is not a HN type.</span>

<span class="sd">        The codimension of the HN stratum of :math:`d^* = (d^1,...,d^s)` is given by</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            - sum_{k &lt; l} &lt;d^k,d^l&gt;</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([1,0])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: hn = X.all_harder_narasimhan_types(); hn</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>
<span class="sd">            sage: [X.codimension_of_harder_narasimhan_stratum(dstar) for dstar in hn]</span>
<span class="sd">            [12, 9, 8, 3, 18, 10, 4, 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dstar</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_harder_narasimhan_type</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dstar</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">))</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.codimension_unstable_locus">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_unstable_locus">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_unstable_locus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of the unstable locus</span>
<span class="sd">        inside the representation variety.</span>

<span class="sd">        OUTPUT: codimension as Int</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], [1, 0])</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            3</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: Q = ThreeVertexQuiver(1,6,1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 6, 6])</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            1</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], [1, 0])</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># note that while the HN types and strata depend on the denominator</span>
        <span class="c1"># the list of all their codimensions does not</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dstar</span> <span class="ow">in</span> <span class="n">HNs</span>
        <span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Luna</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.all_luna_types">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_luna_types">[docs]</a>
    <span class="k">def</span> <span class="nf">all_luna_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the unordered list of all Luna types of d for theta.</span>

<span class="sd">        OUTPUT: list of tuples containing Int-vector and Int</span>

<span class="sd">        A Luna type of d for theta is an unordered sequence (i.e. multiset)</span>
<span class="sd">        :math:`((d^1,m_1),...,(d^s,m_s))` of dimension vectors</span>
<span class="sd">        :math:`d^k` and positive integers :math:`m_k` such that</span>

<span class="sd">        - :math:`m_1d^1 + ... + m_sd^s = d`</span>
<span class="sd">        - :math:`\mu_{\theta}(d^k) = \mu_{\theta}(d)`</span>
<span class="sd">        - All :math:`d^k` admit a :math:`\theta`-stable representation</span>

<span class="sd">        Example: Suppose that `d = 3e` and `e, 2e, d = 3e`</span>
<span class="sd">        are the only stable subdimension vectors.</span>
<span class="sd">        Then the Luna types are</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \begin{aligned}</span>
<span class="sd">                ((3e,1)) \\</span>
<span class="sd">                ((2e,1),(e,1))\\</span>
<span class="sd">                ((e,3))\\</span>
<span class="sd">                ((e,2),(e,1))\\</span>
<span class="sd">                ((e,1),(e,1),(e,1)).</span>
<span class="sd">            \end{aligned}</span>

<span class="sd">        We implement it as follows.</span>

<span class="sd">        A Luna type for us is a dictionary</span>
<span class="sd">        ``{d^1: p_1^1,..., d^s: p_s^1,..., d_s: p_s^t}``</span>
<span class="sd">        of dimension vectors d^k and non-empty partitions p^k such that</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            |p_1^1|d^1 + ... + |p_s^t|d^s = d</span>

<span class="sd">        So in the above example, the Luna types are::</span>

<span class="sd">            {3e: [1]}</span>
<span class="sd">            {2e: [1], e: [1]}</span>
<span class="sd">            {e: [3]}</span>
<span class="sd">            {e: [2, 1]}</span>
<span class="sd">            {e: [1, 1, 1]}</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([3,3]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(1, 1): [3]}, {(1, 1): [2, 1]}, {(1, 1): [1, 1, 1]}]</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([3,3])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(3, 3): [1]},</span>
<span class="sd">             {(1, 1): [1], (2, 2): [1]},</span>
<span class="sd">             {(1, 1): [3]},</span>
<span class="sd">             {(1, 1): [2, 1]},</span>
<span class="sd">             {(1, 1): [1, 1, 1]}]</span>

<span class="sd">        The zero vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([0,0]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(0, 0): [1]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="c1"># Q.zero_vector() can&#39;t be hashed a priori</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">())</span>
            <span class="k">return</span> <span class="p">[{</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}]</span>

        <span class="n">same_slope</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">same_slope</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
                <span class="n">same_slope</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">same_slope</span><span class="p">))</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
        <span class="n">luna_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">same_slope</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                    <span class="c1"># from tau we build all possible Luna types</span>
                    <span class="n">partial</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">taui</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tau</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">taui</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">partial</span><span class="p">[</span><span class="n">taui</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">partial</span><span class="p">[</span><span class="n">taui</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="c1"># partial has the form</span>
                    <span class="c1"># {d^1: Partitions(p^1), ..., d^s: Partitions(p^s)}</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">partial</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

                    <span class="n">new_types</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">values</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">partial</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                    <span class="p">]</span>
                    <span class="n">luna_types</span> <span class="o">+=</span> <span class="n">new_types</span>
        <span class="k">return</span> <span class="n">luna_types</span></div>


<div class="viewcode-block" id="QuiverModuli.is_luna_type">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_luna_type">[docs]</a>
    <span class="k">def</span> <span class="nf">is_luna_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if tau is a Luna type for theta.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- dictionary with dimension vectors as keys and lists of ints as values</span>

<span class="sd">        OUTPUT: whether ``tau`` is a Luna type.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([3,3]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: l = X.all_luna_types()</span>
<span class="sd">            sage: all(X.is_luna_type(tau) for tau in l)</span>
<span class="sd">            True</span>

<span class="sd">        The 3-Kronecker quiver with zero vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([0,0]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: d.set_immutable()</span>
<span class="sd">            sage: X.is_luna_type({d: [1]})</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="c1"># TODO shouldn&#39;t we test for Q._is_dimension_vector?</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">d</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="c1"># Q.zero_vector() can&#39;t be hashed a priori</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">tau</span> <span class="o">==</span> <span class="p">{</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.dimension_of_luna_stratum">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.dimension_of_luna_stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension_of_luna_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the Luna stratum :math:`S_\tau`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- list of tuples</span>
<span class="sd">        - ``secure`` -- Bool</span>

<span class="sd">        OUTPUT: Dimension as Int</span>

<span class="sd">        The dimension of the Luna stratum of</span>
<span class="sd">        ``tau = {d^1: p^1,...,d^s: p^s}`` is</span>
<span class="sd">        :math:`\sum_k l(p^k)(1 - &lt;\langle d^k,d^k\rangle)`,</span>
<span class="sd">        where for a partition :math:`p = (n_1,...,n_l)`,</span>
<span class="sd">        the length `l(p)` is `l`, i.e. the number of summands.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([2,2]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: L = X.all_luna_types(); L</span>
<span class="sd">            [{(1, 1): [2]}, {(1, 1): [1, 1]}]</span>
<span class="sd">            sage: [X.dimension_of_luna_stratum(tau) for tau in L]</span>
<span class="sd">            [1, 2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_luna_type</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">dn</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">dn</span><span class="p">))</span> <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="QuiverModuli.local_quiver_setting">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.local_quiver_setting">[docs]</a>
    <span class="k">def</span> <span class="nf">local_quiver_setting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local quiver and dimension vector for the given Luna type.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- list of tuples</span>
<span class="sd">        - ``secure`` -- Bool</span>

<span class="sd">        OUTPUT: tuple consisting of a Quiver object and a vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,2])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: L = X.all_luna_types(); L</span>
<span class="sd">            [{(2, 2): [1]}, {(1, 1): [2]}, {(1, 1): [1, 1]}]</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(L[0]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix() , dloc</span>
<span class="sd">            ([4], (1))</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(L[1]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix() , dloc</span>
<span class="sd">            ([1], (2))</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(L[2]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix() , dloc</span>
<span class="sd">            (</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [1 1], (1, 1)</span>
<span class="sd">            )</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_luna_type</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="c1"># a word of caution to the future maintainer: Python dictionaries</span>
        <span class="c1"># iterate over the keys in the order they were inserted. This ensures</span>
        <span class="c1"># that the following is a well-defined adjacency matrix. Python sets</span>
        <span class="c1"># DO NOT have this property.</span>
        <span class="c1"># TODO this looks fishy; why should this choice of order matter, as long as</span>
        <span class="c1"># it is the same when defining dloc?</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">generic_ext</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">eq</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">dp</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">Qloc</span> <span class="o">=</span> <span class="n">Quiver</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">dloc</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">dp</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Qloc</span><span class="p">,</span> <span class="n">dloc</span></div>


    <span class="c1"># TODO: The codimension computation requires the dimension of the nullcone. This is hard, it turns out. It can be done with the Hesselink stratification, but I wasn&#39;t willing to go thourgh Lieven&#39;s treatment of this.</span>
    <span class="k">def</span> <span class="nf">_codimension_inverse_image_luna_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of :math:`\pi^{-1}(S_{tau})`</span>
<span class="sd">        inside `R(Q,d)` where :math:`\pi: R(Q,d)^{\theta-sst} --&gt; M^{\theta-sst}(Q,d)`</span>
<span class="sd">        is the semistable quotient map.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau``: list of tuples</span>

<span class="sd">        OUTPUT: codimension as Int</span>

<span class="sd">        For ``tau = {d^1: p^1,...,d^s: p^s}``</span>
<span class="sd">        the codimension of :math:`\pi^{-1}(S_{tau})` is</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            -\langle d,d \rangle + \sum_{k=1}^s</span>
<span class="sd">            (\langle d^k,d^k\rangle - l(p^k) + ||p^k||^2) -</span>
<span class="sd">            \mathrm{dim} N(Q_{tau}, d_{tau}),</span>

<span class="sd">        where for a partition :math:`p = (n_1,...,n_l)`, we define</span>
<span class="sd">        :math:`||p||^2 = \sum_v n_v^2`</span>
<span class="sd">        and :math:`N(Q_{tau}, d_{tau})` is the nullcone of the local quiver setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="n">Qtau</span><span class="p">,</span> <span class="n">dtau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_quiver_setting</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dimNull</span> <span class="o">=</span> <span class="n">Qtau</span><span class="o">.</span><span class="n">dimension_nullcone</span><span class="p">(</span><span class="n">dtau</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">nkv</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">nkv</span> <span class="ow">in</span> <span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">tau</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="o">-</span> <span class="n">dimNull</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QuiverModuli.codimension_properly_semistable_locus">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_properly_semistable_locus">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_properly_semistable_locus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of :math:`R^{\theta-sst}(Q,d)</span>
<span class="sd">        \setminus R^{\theta-st}(Q,d)` inside :math:`R(Q,d)`.</span>

<span class="sd">        OUTPUT: codimension as Int</span>

<span class="sd">        The codimension of the properly semistable locus</span>
<span class="sd">        is the minimal codimension of the inverse image</span>
<span class="sd">        of the non-stable Luna strata.&quot;&quot;&quot;</span>

        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">()</span>
        <span class="c1"># This is the stable Luna type; remove it if it occurs</span>
        <span class="n">dstable</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">tau</span><span class="p">:</span> <span class="n">tau</span> <span class="o">!=</span> <span class="n">dstable</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_codimension_inverse_image_luna_stratum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">L</span><span class="p">])</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (Semi-)stability</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.semistable_equals_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.semistable_equals_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">semistable_equals_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether every semistable representation is stable</span>
<span class="sd">        for the given stability parameter.</span>

<span class="sd">        Every :math:`\theta`-semistable representation is</span>
<span class="sd">        :math:`\theta`-stable if and only if</span>
<span class="sd">        there are no Luna types other than (possibly) ``{d: [1]}``.</span>

<span class="sd">        OUTPUT: whether every theta-semistable representation is theta-stable</span>
<span class="sd">        for ``self._theta``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([3,3])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.semistable_equals_stable()</span>
<span class="sd">            False</span>
<span class="sd">            sage: e = vector([2,3])</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, e, theta)</span>
<span class="sd">            sage: Y.semistable_equals_stable()</span>
<span class="sd">            True</span>

<span class="sd">        A double framed example as in our vector fields paper::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q = Q.framed_quiver([1, 0]).coframed_quiver([0, 0, 1])</span>
<span class="sd">            sage: d = [1, 2, 3, 1]</span>
<span class="sd">            sage: theta = [1, 300, -200, -1]</span>
<span class="sd">            sage: Q.is_theta_coprime(d, theta)</span>
<span class="sd">            False</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.semistable_equals_stable()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># the computation of all Luna types takes so much time</span>
        <span class="c1"># thus we should first tests if d is theta-coprime</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># this is probably the fastest way as checking theta-coprimality is fast</span>
        <span class="c1"># whereas checking for existence of a semi-stable representation</span>
        <span class="c1"># is a bit slower</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allLunaTypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">()</span>
            <span class="n">genericType</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
            <span class="k">if</span> <span class="n">genericType</span> <span class="ow">in</span> <span class="n">allLunaTypes</span><span class="p">:</span>
                <span class="n">allLunaTypes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">genericType</span><span class="p">)</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">allLunaTypes</span>  <span class="c1"># This checks if the list is empty</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ample stability</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.is_amply_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_amply_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">is_amply_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if the dimension vector is amply stable for the stability parameter</span>

<span class="sd">        By definition, a dimension vector `d` is :math:`\theta`-amply stable if the</span>
<span class="sd">        codimension of the :math:`\theta`-semistable locus</span>
<span class="sd">        inside `R(Q,d)` is at least 2.</span>

<span class="sd">        OUTPUT: whether the data for the quiver moduli space is amply stable</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [2, 3]).is_amply_stable()</span>
<span class="sd">            True</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [2, 3], [-3, 2]).is_amply_stable()</span>
<span class="sd">            False</span>

<span class="sd">        A three-vertex example from the rigidity paper::</span>

<span class="sd">            sage: Q = ThreeVertexQuiver(1, 6, 1)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [1, 6, 6]).is_amply_stable()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dstar</span> <span class="ow">in</span> <span class="n">HNs</span>
            <span class="p">)</span>
            <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.is_strongly_amply_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_strongly_amply_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">is_strongly_amply_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if the dimension vector is strongly amply stable for the stability</span>
<span class="sd">        parameter</span>

<span class="sd">        We call `d` strongly amply stable for :math:`\theta` if</span>
<span class="sd">        :math:`\langle e,d-e\rangle \leq -2`</span>
<span class="sd">        holds for all subdimension vectors :math:`e` of :math:`d` which satisfy</span>
<span class="sd">        :math:`\mu_{\theta}(e) &gt;= \mu_{\theta}(d)`.</span>

<span class="sd">        OUTPUT: whether the data for the quiver moduli space is strongly amply stable</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [2, 3]).is_strongly_amply_stable()</span>
<span class="sd">            True</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(5, 1, 1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [4, 1, 4])</span>
<span class="sd">            sage: X.is_amply_stable()</span>
<span class="sd">            True</span>
<span class="sd">            sage: X.is_strongly_amply_stable()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># subdimension vectors of smaller slope</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
        <span class="n">es</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">slope</span><span class="p">,</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">es</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Methods related to Teleman quantization</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.harder_narasimhan_weight">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.harder_narasimhan_weight">[docs]</a>
    <span class="k">def</span> <span class="nf">harder_narasimhan_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">harder_narasimhan_type</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Teleman weight of a Harder-Narasimhan type</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``harder_narasimhan_type`` -- list of vectors of Ints</span>

<span class="sd">        OUTPUT: weight as a fraction</span>

<span class="sd">        The weight of a Harder-Narasimhan type :math:`d^*`</span>
<span class="sd">        is the weight of the associated 1-PS :math:`\lambda` acting on</span>
<span class="sd">        :math:`\det(N_{S/R})^{\vee}|_Z`, where `S` is the</span>
<span class="sd">        corresponding Harder--Narasimhan stratum.</span>

<span class="sd">        .. SEEALSO:: :meth:`all_weight_bounds`, :meth:`if_rigidity_inequality_holds`</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], [3, -2])</span>
<span class="sd">            sage: HN = X.all_harder_narasimhan_types(proper=True)</span>
<span class="sd">            sage: {hntype: X.harder_narasimhan_weight(hntype) for hntype in HN}</span>
<span class="sd">            {((1, 0), (1, 1), (0, 2)): 45,</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)): 100/3,</span>
<span class="sd">             ((1, 0), (1, 3)): 30,</span>
<span class="sd">             ((1, 1), (1, 2)): 5/2,</span>
<span class="sd">             ((2, 0), (0, 3)): 90,</span>
<span class="sd">             ((2, 1), (0, 2)): 100/3,</span>
<span class="sd">             ((2, 2), (0, 1)): 10}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span>
        <span class="n">HN</span> <span class="o">=</span> <span class="n">harder_narasimhan_type</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">HN</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HN</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">HN</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.all_weight_bounds">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_weight_bounds">[docs]</a>
    <span class="k">def</span> <span class="nf">all_weight_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all weights appearing in Teleman quantization.</span>

<span class="sd">        For each HN type, the 1-PS lambda acts on :math:`\det(N_{S/R}^{\vee}|_Z)`</span>
<span class="sd">        with a certain weight. Teleman quantization gives a numerical condition</span>
<span class="sd">        involving these weights to compute cohomology on the quotient.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``as_dict`` -- (default: False) when True it will give a dict whose keys are</span>
<span class="sd">          the HN-types and whose values are the weights</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 6-dimensional 3-Kronecker example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: X = QuiverModuliSpace(KroneckerQuiver(3), [2, 3])</span>
<span class="sd">            sage: X.all_weight_bounds()</span>
<span class="sd">            [135, 100, 90, 15/2, 270, 100, 30]</span>
<span class="sd">            sage: X.all_weight_bounds(as_dict=True)</span>
<span class="sd">            {((1, 0), (1, 1), (0, 2)): 135,</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)): 100,</span>
<span class="sd">             ((1, 0), (1, 3)): 90,</span>
<span class="sd">             ((1, 1), (1, 2)): 15/2,</span>
<span class="sd">             ((2, 0), (0, 3)): 270,</span>
<span class="sd">             ((2, 1), (0, 2)): 100,</span>
<span class="sd">             ((2, 2), (0, 1)): 30}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is only relevant on the unstable locus</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">HN</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">harder_narasimhan_weight</span><span class="p">(</span><span class="n">HN</span><span class="p">),</span> <span class="n">HNs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">HNs</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.if_rigidity_inequality_holds">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.if_rigidity_inequality_holds">[docs]</a>
    <span class="k">def</span> <span class="nf">if_rigidity_inequality_holds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        OUTPUT: whether the rigidity inequality holds on the given moduli</span>

<span class="sd">        If the weights of the 1-PS lambda on :math:`\det(N_{S/R}|_Z)` for each HN type</span>
<span class="sd">        are all strictly larger than the weights of the tensors of the universal bundles</span>
<span class="sd">        :math:`U_i^\vee \otimes U_j`,</span>
<span class="sd">        then the resulting moduli space is infinitesimally rigid.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: X = QuiverModuliSpace(KroneckerQuiver(3), [2, 3])</span>
<span class="sd">            sage: X.if_rigidity_inequality_holds()</span>
<span class="sd">            True</span>
<span class="sd">            sage: X = QuiverModuliSpace(ThreeVertexQuiver(1, 6, 1), [1, 6, 6])</span>
<span class="sd">            sage: X.if_rigidity_inequality_holds()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denom</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_weight_bounds</span><span class="p">()</span>

        <span class="c1"># we compute the maximum weight of the tensors of the universal bundles</span>
        <span class="c1"># this is only relevant on the unstable locus</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">tensor_weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">HN</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
                <span class="n">HNs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tensor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HNs</span><span class="p">)))</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tautological relations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_all_forbidden_subdimension_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all forbidden subdimension vectors</span>

<span class="sd">        These are the dimension vectors `d&#39;` of d for which</span>

<span class="sd">        - :math:`\mu_{\theta}(d&#39;) &gt; \mu_{\theta}(d)` (in the semistable case)</span>
<span class="sd">        - or for which :math:`\mu_{\theta}(d&#39;) &gt;= \mu_{\theta}(d)` (in the stable case).</span>

<span class="sd">        OUTPUT: list of forbidden subdimension vectors vectors</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X._all_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2)]</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X._all_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>

        <span class="n">es</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># TODO need for denominator?</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">slope</span><span class="p">,</span> <span class="n">es</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">slope</span><span class="p">,</span> <span class="n">es</span><span class="p">))</span>

    <span class="c1"># TODO make it private?</span>
<div class="viewcode-block" id="QuiverModuli.all_minimal_forbidden_subdimension_vectors">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_minimal_forbidden_subdimension_vectors">[docs]</a>
    <span class="k">def</span> <span class="nf">all_minimal_forbidden_subdimension_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all `minimal` forbidden subdimension vectors</span>

<span class="sd">        Minimality is with respect to the partial order `e &lt;&lt; d` which means</span>
<span class="sd">        :math:`e_i \leq d_i` for every source `i`, :math:`e_j \geq d_j`</span>
<span class="sd">        for every sink `j`, and :math:`e_k = d_k` for every vertex which is neither</span>
<span class="sd">        a source nor a sink. See also :meth:`Quiver.division_order`.</span>

<span class="sd">        OUTPUT: list of minimal forbidden dimension vectors</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.all_minimal_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (2, 1), (3, 2)]</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: Y.all_minimal_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 1), (2, 2)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="n">forbidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_forbidden_subdimension_vectors</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">is_minimal</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">division_order</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">e</span><span class="p">,</span> <span class="n">forbidden</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_minimal</span><span class="p">,</span> <span class="n">forbidden</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">__tautological_presentation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the tautological relations in Chern classes</span>
<span class="sd">        (if ``inRoots == False``) or in Chern roots.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``inRoots`` -- Bool</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>
<span class="sd">        - ``chernRoots`` -- list of Strings</span>

<span class="sd">        OUTPUT: dict</span>

<span class="sd">        # TODO</span>
<span class="sd">        Explanation ...</span>

<span class="sd">        Notation for explanations:</span>
<span class="sd">        G = G_d = prod_{i in Q_0} GL_{d_i}</span>
<span class="sd">        T = maximal torus of diagonal matrices</span>
<span class="sd">        PG = G/G_m</span>
<span class="sd">        PT = T/G_m maximal torus of PT</span>
<span class="sd">        W = Weyl group of T in G = Weyl group of PT in PG</span>
<span class="sd">          = prod_{i in Q_0} S_{d_i}</span>
<span class="sd">        R = bigoplus_{a in Q_1} Hom(k^{d_{s(a)}},k^{d_{t(a)}})</span>
<span class="sd">        R^{sst}, R^{st} semi-stable/stable locus</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        # TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">chernRoots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernRoots</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;t</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">chernRoots</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns generator(R, i, r) = t{i+1}_{r+1}.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]))</span>

<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generators of the tautological ideal regarded upstairs, i.e. in A*([R/T]).</span>
<span class="sd">        For a forbidden subdimension vector e of d, the forbidden polynomial in Chern</span>
<span class="sd">        roots is given by :math:`\prod_{a: i \to j} \prod_{r=1}^{e_i}</span>
<span class="sd">        \prod_{s=e_j+1}^{d_j} (tj_s - ti_r) =</span>
<span class="sd">        \prod_{i,j} \prod_{r=1}^{e_i} \prod_{s=e_j+1}^{d_j} (tj_s - ti_r)^{a_{ij}}.&quot;&quot;&quot;</span>
        <span class="n">forbiddenPolynomials</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="p">(</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
                            <span class="o">**</span> <span class="n">Q</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_minimal_forbidden_subdimension_vectors</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">inRoots</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;ParentRing&quot;</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
                <span class="s2">&quot;Generators&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
                <span class="s2">&quot;Relations&quot;</span><span class="p">:</span> <span class="n">forbiddenPolynomials</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;delta is the discriminant&quot;&quot;&quot;</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;longest is the longest Weyl group element</span>
<span class="sd">            when regarding W as a subgroup of S_{sum d_i}&quot;&quot;&quot;</span>
            <span class="n">longest</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">longest</span> <span class="o">=</span> <span class="n">longest</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">bruhat_smaller</span><span class="o">=</span><span class="n">longest</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">antisymmetrization</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;The antisymmetrization of f is the symmetrization</span>
<span class="sd">                divided by the discriminant.&quot;&quot;&quot;</span>

                <span class="c1"># I don&#39;t want to define W and delta here but globally because then</span>
                <span class="c1"># we need to compute it just once. That&#39;s probably a bit faster.</span>
                <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">ngens</span><span class="p">())})</span>

                <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="n">permute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">W</span><span class="p">)</span> <span class="o">//</span> <span class="n">delta</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Schubert basis of A^*([R/T]) over A^*([R/G])&quot;&quot;&quot;</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">SchubertPolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())))</span>

            <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>

            <span class="n">Bprime</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">ngens</span><span class="p">())],</span> <span class="n">R</span>
                    <span class="p">)(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">supp</span>
            <span class="p">]</span>

            <span class="c1"># TODO is this not something already implemented?</span>
            <span class="c1"># if not, explain what it does!</span>
            <span class="k">def</span> <span class="nf">product_lists</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="n">product_lists</span><span class="p">([</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="n">l</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">schubert</span> <span class="o">=</span> <span class="n">product_lists</span><span class="p">(</span><span class="n">Bprime</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Define A = A*([R/G]).&quot;&quot;&quot;</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">chernClasses</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">TermOrder</span><span class="p">(</span><span class="s2">&quot;wdegrevlex&quot;</span><span class="p">,</span> <span class="n">degrees</span><span class="p">))</span>

            <span class="n">E</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;The Chern classes of U_i on [R/G] are the elementary symmetric functions</span>
<span class="sd">            in the Chern roots ti_1,...,ti_{d_i}.&quot;&quot;&quot;</span>
            <span class="n">elementarySymmetric</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">elementarySymmetric</span> <span class="o">=</span> <span class="n">elementarySymmetric</span> <span class="o">+</span> <span class="p">[</span>
                    <span class="n">E</span><span class="p">([</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">]</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Map xi_r to the r-th elementary symmetric function</span>
<span class="sd">            in ti_1,...,ti_{d_i}.&quot;&quot;&quot;</span>
            <span class="n">inclusion</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">elementarySymmetric</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Tautological relations in Chern classes.&quot;&quot;&quot;</span>
            <span class="n">tautological</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">antisymmetrization</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">schubert</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">forbiddenPolynomials</span>
            <span class="p">]</span>
            <span class="n">tautological</span> <span class="o">=</span> <span class="p">[</span><span class="n">inclusion</span><span class="o">.</span><span class="n">inverse_image</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">tautological</span><span class="p">]</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;ParentRing&quot;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span>
                <span class="s2">&quot;Generators&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">generator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
                <span class="s2">&quot;Relations&quot;</span><span class="p">:</span> <span class="n">tautological</span><span class="p">,</span>
            <span class="p">}</span>

<div class="viewcode-block" id="QuiverModuli.tautological_relations">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.tautological_relations">[docs]</a>
    <span class="k">def</span> <span class="nf">tautological_relations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tautological relations in</span>
<span class="sd">        Chern classes (if inRoots == False) or in Chern roots.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``inRoots`` -- Bool</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>
<span class="sd">        - ``chernRoots`` -- list of Strings</span>

<span class="sd">        OUTPUT: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="n">inRoots</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="n">chernRoots</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="QuiverModuli.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dimension of the moduli space.</span>

<span class="sd">        Abstract method, see the concrete implementations for details.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`QuiverModuliSpace.dimension`,</span>
<span class="sd">            - :meth:`QuiverModuliStack.dimension`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuli.is_smooth">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the moduli space is smooth.</span>

<span class="sd">        Abstract method, see the concrete implementations for details.</span>

<span class="sd">        .. SEEALSO::</span>

<span class="sd">            - :meth:`QuiverModuliSpace.is_smooth`</span>
<span class="sd">            - :meth:`QuiverModuliStack.is_smooth`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuli.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Chow ring of the moduli space.</span>

<span class="sd">        Abstract method, see the concrete implementations for details.</span>

<span class="sd">        .. SEEALSO:: :meth:`QuiverModuliSpace.chow_ring`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="QuiverModuliSpace">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuliSpace</span><span class="p">(</span><span class="n">QuiverModuli</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Constructor for a quiver moduli space</span>

<span class="sd">        This is the quiver moduli space as a variety.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``Q`` -- quiver</span>

<span class="sd">        - ``d`` --- dimension vector</span>

<span class="sd">        - ``theta`` -- stability parameter (default: canonical stability parameter)</span>

<span class="sd">        - ``denom`` -- denominator for slope stability (default: ``sum``), needs to be</span>
<span class="sd">          effective on the simple roots</span>

<span class="sd">        - ``condition`` -- whether to include all semistables, or only stables</span>
<span class="sd">          (default: &quot;semistable&quot;)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">QuiverModuli</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">Q</span><span class="p">,</span>
            <span class="n">d</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
            <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">,</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for the quiver moduli space</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_QuiverModuli__repr_helper</span><span class="p">(</span><span class="s2">&quot;moduli space&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliSpace.repr">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.repr">[docs]</a>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for the quiver moduli space</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli space::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, (2, 3))</span>
<span class="sd">            moduli space of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the moduli space :math:`M^{\theta-(s)st}(Q,d)`.</span>

<span class="sd">        This involves several cases:</span>

<span class="sd">        - If there are :math:`\theta`-stable representations then</span>
<span class="sd">          :math:`\mathrm{dim} M^{\theta-sst}(Q,d) =</span>
<span class="sd">          M^{\theta-st}(Q,d) = 1 - \langle d,d\rangle`;</span>
<span class="sd">        - if there are no :math:`\theta`-stable representations then</span>
<span class="sd">          :math:`\mathrm{dim} M^{\theta-st}(Q,d) = -\infty` by convention,</span>
<span class="sd">          and we define :math:`\mathrm{dim} M^{\theta-sst} =</span>
<span class="sd">          \mathrm{max}_{\tau} \{\mathrm{dim} S_{\tau}\}`,</span>
<span class="sd">          the maximum of the dimension of all Luna strata.</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        The A2-quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(2)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            1</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            1</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            2</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            6</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3],condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            10</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 3],condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 4],condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 4],condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if there are stable representations then both the stable and</span>
        <span class="c1"># the semi-stable moduli space have dimension `1-&lt;d,d&gt;`</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="c1"># stable locus is empty</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span>

        <span class="c1"># we care about the semistable locus</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="c1"># in this case the dimension is given by</span>
            <span class="c1"># the maximum of the dimensions of the Luna strata</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dimension_of_luna_stratum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="c1"># semistable locus is also empty</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.poincare_polynomial">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.poincare_polynomial">[docs]</a>
    <span class="k">def</span> <span class="nf">poincare_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Poincare polynomial of the moduli space.</span>

<span class="sd">        OUTPUT: polynomial in one variable</span>
<span class="sd">        # TODO allow a user-supplied ring?</span>

<span class="sd">        The Poincare polynomial is defined as</span>

<span class="sd">        .. MATH::</span>
<span class="sd">            P_X(q) = \sum_{i \geq 0} (-1)^i \mathrm{dim} H^i(X;\mathbb{C}) q^{i/2}.</span>

<span class="sd">        For a quiver moduli space whose dimension vector is</span>
<span class="sd">        :math:`\theta`-coprime, the odd cohomology vanishes</span>
<span class="sd">        and this is a Polynomial in :math:`q`.</span>
<span class="sd">        We use Cor. 6.9 in Reineke&#39;s Harder--Narasimhan paper to compute it.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some Kronecker quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1])</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q + 1</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3])</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q^6 + q^5 + 3*q^4 + 3*q^3 + 3*q^2 + q + 1</span>
<span class="sd">            sage: Q = SubspaceQuiver(5)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1, 1, 1, 1, 2])</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q^2 + 5*q + 1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">QuiverModuliStack</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">motive</span><span class="p">())</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.betti_numbers">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.betti_numbers">[docs]</a>
    <span class="k">def</span> <span class="nf">betti_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Betti numbers of the moduli space.</span>

<span class="sd">        OUTPUT: List of Ints</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some Kronecker quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([1,1]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q + 1</span>
<span class="sd">            sage: X.betti_numbers()</span>
<span class="sd">            [1, 0, 1]</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.betti_numbers()</span>
<span class="sd">            [1, 0, 1, 0, 3, 0, 3, 0, 3, 0, 1, 0, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="c1"># p is the prime place of the DVR associated with v</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">zeros</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">ext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poincare_polynomial</span><span class="p">())</span>
        <span class="n">betti</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="n">v</span>
            <span class="n">betti</span> <span class="o">=</span> <span class="n">betti</span> <span class="o">+</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">betti</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.is_smooth">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.is_smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># if theta-coprime then you can shortcut everything</span>
        <span class="c1"># if theta != 0 reduce to theta = 0 using https://mathscinet.ams.org/mathscinet-getitem?mr=1972892 (Adriaenssens--Le Bruyn)</span>
        <span class="c1"># if theta = 0, then use https://mathscinet.ams.org/mathscinet-getitem?mr=1929191 (Bocklandt)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">is_projective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="QuiverModuliSpace.picard_rank">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.picard_rank">[docs]</a>
    <span class="k">def</span> <span class="nf">picard_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the Picard rank of the moduli space for known cases.&quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="c1"># TODO requires smooth and projective?</span>

        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_amply_stable</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO if smooth: compute the Betti numbers and return b_2</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.index">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the index of the moduli space for known cases,</span>
<span class="sd">        i.e., the largest integer dividing the canonical divisor in Pic.&quot;&quot;&quot;</span>
        <span class="c1"># TODO this should really be a check for theta belonging to the canonical chamber, rather than being equal to the canonical stability.</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="c1"># TODO at the very least check for multiple of canonical</span>
            <span class="n">theta</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_amply_stable</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># TODO what if theta is rescaled?</span>
            <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_to_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


        <span class="c1"># TODO ample stability for the canonical stability parameter should be an attribute of the object, so that it is only computed once. Verbatim for many other attributes.</span>

    <span class="k">def</span> <span class="nf">mukai_inequality_holds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">picard_rank</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliSpace.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Chow ring of the moduli space.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``chi`` -- vector of Ints</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>

<span class="sd">        OUTPUT: ring</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([1,1]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([1,0])</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1], [x1_1]]</span>


<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([3,-2])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,1])</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1],</span>
<span class="sd">            [x1_1],</span>
<span class="sd">            [x0_2, x1_1^2, x1_2],</span>
<span class="sd">            [x1_1^3, x1_1*x1_2, x1_3],</span>
<span class="sd">            [x1_1^2*x1_2, x1_2^2, x1_1*x1_3],</span>
<span class="sd">            [x1_2*x1_3],</span>
<span class="sd">            [x1_3^2]]</span>

<span class="sd">        The 5-subspaces quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = SubspaceQuiver(5), vector([1,1,1,1,1,2])</span>
<span class="sd">            sage: theta = vector([2,2,2,2,2,-5])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,-1,-1,-1,-1,3])</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1], [x1_1, x2_1, x3_1, x4_1, x5_1], [x5_2]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>

        <span class="c1"># This implementation only works if d is theta-coprime</span>
        <span class="c1"># which implies that d is indivisible.</span>
        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_QuiverModuli__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">rels</span> <span class="o">=</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;ParentRing&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Generators&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">chi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># TODO assert that chi has integer entries.</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure that chi has weight one, i.e.,</span>
<span class="sd">        provides a retraction for X*(PG) --&gt; X*(G).&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">chi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="n">I</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">rels</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">chi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">generator</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]))</span>

        <span class="k">return</span> <span class="n">QuotientRing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.chern_class_line_bundle">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chern_class_line_bundle">[docs]</a>
    <span class="k">def</span> <span class="nf">chern_class_line_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first Chern class of the line bundle</span>
<span class="sd">        :math:`L(\eta) = \bigotimes_{i \in Q_0} \det(U_i)^{-\eta_i}`,</span>
<span class="sd">        where :math:`\eta` is a character of :math:`PG_d`.&quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">([</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.chern_character_line_bundle">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chern_character_line_bundle">[docs]</a>
    <span class="k">def</span> <span class="nf">chern_character_line_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Chern character of L(eta).</span>

<span class="sd">        The Chern character of a line bundle `L` with first Chern class `x`</span>
<span class="sd">        is given by :math:`e^x = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \dots`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chern_class_line_bundle</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.total_chern_class_universal">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.total_chern_class_universal">[docs]</a>
    <span class="k">def</span> <span class="nf">total_chern_class_universal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives the total Chern class of the universal bundle U_i(chi).&quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.point_class">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.point_class">[docs]</a>
    <span class="k">def</span> <span class="nf">point_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the point class as an expression in Chern classes of the</span>
<span class="sd">        :math:`U_i` (``chi``).</span>

<span class="sd">        The point class is given as the homogeneous component of degree</span>
<span class="sd">        :math:`\mathrm{dim} X` of the expression</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \prod_{a \in Q_1} c(U_{t(a)})^{d_{s(a)}} / (\prod_{i \in Q_0} c(U_i)^{d_i})</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        :math:`\mathbb{P}^7` as a quiver moduli space</span>
<span class="sd">        of a generalized Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(8)</span>
<span class="sd">            sage: d = vector([1,1])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([1,0])</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;o&#39;,&#39;h&#39;])</span>
<span class="sd">            h^7</span>

<span class="sd">        Our favorite 6-fold::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: d = vector([2,3])</span>
<span class="sd">            sage: theta = vector([3,-2])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,1])</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;x1&#39;,&#39;x2&#39;,&#39;y1&#39;,&#39;y2&#39;,&#39;y3&#39;])</span>
<span class="sd">            y3^2</span>

<span class="sd">        A moduli space of the 5-subspaces quiver;</span>
<span class="sd">        it agrees with the blow-up of :math:`\mathbb{P}^2` in 4 points</span>
<span class="sd">        in general position::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = SubspaceQuiver(5)</span>
<span class="sd">            sage: d = vector([1,1,1,1,1,2])</span>
<span class="sd">            sage: theta = vector([2,2,2,2,2,-5])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,-1,-1,-1,-1,3])</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;x1&#39;,&#39;x2&#39;,&#39;x3&#39;,&#39;x4&#39;,&#39;x5&#39;,&#39;y&#39;,&#39;z&#39;])</span>
<span class="sd">            1/2*z</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="o">=</span><span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">cover</span><span class="p">()</span>  <span class="c1"># The quotient map</span>
        <span class="n">sect</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">lifting_map</span><span class="p">()</span>  <span class="c1"># A choice of a section of pi</span>

        <span class="k">if</span> <span class="n">chi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">my_numerator</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">total_chern_class_universal</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
                <span class="o">**</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">my_denom</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">total_chern_class_universal</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
                <span class="o">**</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">quotient</span> <span class="o">=</span> <span class="n">my_numerator</span> <span class="o">/</span> <span class="n">my_denom</span>

        <span class="k">return</span> <span class="n">pi</span><span class="p">(</span><span class="n">sect</span><span class="p">(</span><span class="n">quotient</span><span class="p">)</span><span class="o">.</span><span class="n">homogeneous_components</span><span class="p">()[</span><span class="n">N</span><span class="p">])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.degree">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.degree">[docs]</a>
    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the degree of the ample line bundle given by eta.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Need check for ampleness first</span>

        <span class="k">if</span> <span class="n">eta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chern_class_line_bundle</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_class</span><span class="p">(</span><span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">c</span><span class="o">**</span><span class="n">N</span> <span class="o">/</span> <span class="n">p</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.todd_class">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.todd_class">[docs]</a>
    <span class="k">def</span> <span class="nf">todd_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Todd class of `X` is the Todd class of the tangent bundle.</span>

<span class="sd">        For quiver moduli it computes as</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            td(X) =</span>
<span class="sd">            (\prod_{a:i \to j \in Q_1} \prod_{p=1}^{d_j} \prod_{q=1}^{d_i} Q(t_{j,q} -</span>
<span class="sd">            t_{i,p}))/(prod_{i \in Q_0} \prod_{p,q=1}^{d_i} Q(t_{i,q} - t_{i,p}))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">todd_generating_series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            We call the series :math:`Q(t) = t/(1-e^{-t})` the Todd generating series.</span>

<span class="sd">            The function computes the terms of this series up to degree n.&quot;&quot;&quot;</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">i</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="o">^</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

        <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Takes an element in a graded ring and discards</span>
<span class="sd">            all homogeneous components of degree &gt; n&quot;&quot;&quot;</span>
            <span class="n">hom</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">homogeneous_components</span><span class="p">()</span>
            <span class="n">keyList</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hom</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">hom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">,</span> <span class="n">keyList</span><span class="p">)])</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>
</div>


    <span class="c1"># TODO: This is maybe too specific.</span>
    <span class="c1"># def diagonal(self, chi=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Computes the class of the diagonal in the Chow ring of X x X where X is the quiver moduli space.&quot;&quot;&quot;</span>
    <span class="c1">#     &quot;&quot;&quot;It is given by the homogeneous component of degree dim X = 1 - &lt;d,d&gt; of the expression c(F)/C(E), where E = bigoplus_{i in Q_0} U_i^vee boxtimes U_i and F = bigoplus_{a in Q_1} U_{s(a)}^vee boxtimes U_{t(a)} = bigoplus_{i,j in Q_0} (U_i^vee boxtimes U_j)^{a_ij}.&quot;&quot;&quot;</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     EXAMPLES</span>

    <span class="c1">#     P^2 as a quiver moduli space:</span>
    <span class="c1">#     sage: from quiver import *</span>
    <span class="c1">#     sage: Q = GeneralizedKroneckerQuiver(3)</span>
    <span class="c1">#     sage: d = vector([1,1])</span>
    <span class="c1">#     sage: theta = vector([1,-1])</span>
    <span class="c1">#     sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
    <span class="c1">#     sage: X.diagonal()</span>
    <span class="c1">#     x1_1^2 + x1_1*y1_1 + y1_1^2</span>

    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     Q, d, theta = self._Q, self._d, self._theta</span>
    <span class="c1">#     n = Q.number_of_vertices()</span>
    <span class="c1">#     N = self.dimension()</span>
    <span class="c1">#     a = Q.adjacency_matrix()</span>

    <span class="c1">#     di = self._QuiverModuli__tautological_presentation()</span>
    <span class="c1">#     A = di[&quot;Generators&quot;]</span>
    <span class="c1">#     I = di[&quot;Relations&quot;] + A.ideal(chi)</span>

    <span class="c1">#     chernClasses1 = [&#39;x%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernClasses2 = [&#39;y%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernClasses = chernClasses1+chernClasses2</span>

    <span class="c1">#     AxA = PolynomialRing(QQ,chernClasses)</span>
    <span class="c1">#     inclusion1 = A.hom(chernClasses1,AxA)</span>
    <span class="c1">#     inclusion2 = A.hom(chernClasses2,AxA)</span>
    <span class="c1">#     B = QuotientRing(AxA,inclusion1(I) + inclusion2(I),names=chernClasses)</span>

    <span class="c1">#     pi = B.cover() # The quotient map AxA --&gt; B</span>
    <span class="c1">#     sect = B.lifting_map() # A choice of a section of pi</span>

    <span class="c1">#     chernRoots1 = [&#39;t%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernRoots2 = [&#39;u%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernRoots = chernRoots1+chernRoots2</span>
    <span class="c1">#     RxR = PolynomialRing(QQ,chernRoots)</span>

    <span class="c1">#     def generatorRxR1(i,r):</span>
    <span class="c1">#         &quot;&quot;&quot;Returns generatorRxR1(i,r) = t{i+1}_{r+1}.&quot;&quot;&quot;</span>
    <span class="c1">#         return RxR.gen(r + sum([d[j] for j in range(i)]))</span>

    <span class="c1">#     def generatorRxR2(i,r):</span>
    <span class="c1">#         &quot;&quot;&quot;Returns generatorRxR2(i,r) = u{i+1}_{r+1}.&quot;&quot;&quot;</span>
    <span class="c1">#         return RxR.gen(sum([d[j] for j in range(n)]) + r + sum([d[j] for j in range(i)]))</span>

    <span class="c1">#     E = SymmetricFunctions(ZZ).e()</span>
    <span class="c1">#     elementarySymmetric1 = []</span>
    <span class="c1">#     elementarySymmetric2 = []</span>
    <span class="c1">#     for i in range(n):</span>
    <span class="c1">#         elementarySymmetric1 = elementarySymmetric1 + [E([k]).expand(d[i], alphabet=[generatorRxR1(i,r) for r in range(d[i])]) for k in range(1,d[i]+1)]</span>
    <span class="c1">#         elementarySymmetric2 = elementarySymmetric2 + [E([k]).expand(d[i], alphabet=[generatorRxR2(i,r) for r in range(d[i])]) for k in range(1,d[i]+1)]</span>
    <span class="c1">#     elementarySymmetric = elementarySymmetric1 + elementarySymmetric2</span>
    <span class="c1">#     &quot;&quot;&quot;Map xi_r to the r-th elementary symmetric function in ti_1,...,ti_{d_i} and yi_r to the same in ui_1,...,ui_{d_i}.&quot;&quot;&quot;</span>
    <span class="c1">#     inclusion = AxA.hom(elementarySymmetric, RxR)</span>

    <span class="c1">#     def total_chern_class_boxproduct(i,j):</span>
    <span class="c1">#         &quot;&quot;&quot;Computes the total Chern class of U_i^vee boxtimes U_j&quot;&quot;&quot;</span>
    <span class="c1">#         c = prod([(1-generatorRxR1(i,r)+generatorRxR2(j,s)) for r in range(d[i]) for s in range(d[j])])</span>
    <span class="c1">#         return pi(inclusion.inverse_image(c))</span>

    <span class="c1">#     numerator = prod([total_chern_class_boxproduct(i,j)**a[i,j] for i in range(n) for j in range(n)])</span>
    <span class="c1">#     denominator = prod([total_chern_class_boxproduct(i,i) for i in range(n)])</span>
    <span class="c1">#     quotient = numerator/denominator</span>

    <span class="c1">#     return pi(sect(quotient).homogeneous_components()[N])</span>


<div class="viewcode-block" id="QuiverModuliStack">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuliStack</span><span class="p">(</span><span class="n">QuiverModuli</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for a quiver moduli stack.</span>

<span class="sd">        This is the quiver moduli space as a stack.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``Q`` -- quiver</span>

<span class="sd">        - ``d`` --- dimension vector</span>

<span class="sd">        - ``theta`` -- stability parameter (default: canonical stability parameter)</span>

<span class="sd">        - ``denom`` -- denominator for slope stability (default: ``sum``), needs to be</span>
<span class="sd">          effective on the simple roots</span>

<span class="sd">        - ``condition`` -- whether to include all semistables, or only stables</span>
<span class="sd">          (default: &quot;semistable&quot;)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        An example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, [2, 3])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">QuiverModuli</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;.</span>
<span class="sd">        Give a shorthand string presentation for the quiver moduli stack</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli stack::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliStack(Q, (2, 3))</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_custom_name</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_QuiverModuli__repr_helper</span><span class="p">(</span><span class="s2">&quot;moduli stack&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliStack.repr">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.repr">[docs]</a>
    <span class="k">def</span> <span class="nf">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a shorthand string presentation for a quiver moduli stack.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        A Kronecker moduli spac::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliStack(Q, (2, 3))</span>
<span class="sd">            moduli stack of semistable representations, with</span>
<span class="sd">            - Q = 3-Kronecker quiver</span>
<span class="sd">            - d = (2, 3)</span>
<span class="sd">            - θ = (9, -6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliStack.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the moduli stack :math:`[R^{(s)st}/G]`.</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            dim [R^{(s)st}/G] = dim R^{(s)st} - dim G</span>

<span class="sd">        The dimension turns out to be :math:`-\langle d,d\rangle`</span>
<span class="sd">        if the (semi-)stable locus is non-empty&quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="c1"># TODO is this one correct? we need to check for existence of a stable I think?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">theta</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span></div>


<div class="viewcode-block" id="QuiverModuliStack.is_smooth">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.is_smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># TODO think about the empty case, should it be smooth?</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="QuiverModuliStack.motive">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.motive">[docs]</a>
    <span class="k">def</span> <span class="nf">motive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gives an expression for the motive of the semistable moduli stack</span>
<span class="sd">        in an appropriate localization of K_0(Var)</span>

<span class="sd">        # TODO more explanation</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Loop quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = LoopQuiver(0), vector([2]), vector([0])</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            1/(L^4 - L^3 - L^2 + L)</span>
<span class="sd">            sage: Q, d, theta = LoopQuiver(1), vector([2]), vector([0])</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            L^3/(L^3 - L^2 - L + 1)</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([3,-2])</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            (-L^6 - L^5 - 3*L^4 - 3*L^3 - 3*L^2 - L - 1)/(L - 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Only for semistable.</span>
        <span class="c1"># For stable, we don&#39;t know what the motive is. It&#39;s not pure in general.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span>
        <span class="c1"># TODO well: if we have stable == semistable then we can also compute it!</span>

        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

        <span class="c1"># TODO allow some other ring?</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># TODO coercion needs to be checked here</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">([(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO use proper=True, nonzero=True, or maybe not?</span>
            <span class="c1"># in any case, the next 6 lines are an atrocity</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">()</span> <span class="ow">and</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">d</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>
            <span class="n">I</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">),</span> <span class="n">I</span><span class="p">))</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">(),</span> <span class="n">d</span><span class="p">]</span>
            <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>
            <span class="c1"># TODO I believe max(d) on a dict should give the wrong result</span>
            <span class="n">I</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">_deglex_key</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

            <span class="c1"># Now define a matrix T of size NxN whose entry at position (i,j) is</span>
            <span class="c1"># L^&lt;e-f,e&gt;*mot(f-e) if e = I[i] is a subdimension vector of f = I[j]</span>
            <span class="c1"># and 0 otherwise</span>
            <span class="c1"># TODO it&#39;s bad to have a function motive inside a motive method</span>
            <span class="k">def</span> <span class="nf">motive</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">QuiverModuliStack</span><span class="p">(</span>
                    <span class="n">Q</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">(),</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">motive</span><span class="p">()</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
                    <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_subdimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
                        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="o">*</span> <span class="n">motive</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">e</span><span class="p">)</span>

            <span class="c1"># Solve system of linear equations T*x = e_N</span>
            <span class="c1"># and extract entry 0 of the solution x.</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
            <span class="n">y</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="QuiverModuliStack.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the Chow ring of the quotient stack.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``chernClasses``: list of Strings</span>

<span class="sd">        OUTPUT: ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="c1"># TODO there is very similar code earlier</span>
        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_QuiverModuli__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rels</span> <span class="o">=</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;ParentRing&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Generators&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">QuotientRing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">rels</span><span class="p">),</span> <span class="n">names</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">SmoothModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;How about this: instead of a separate class SmoothModel,</span>
<span class="sd">    we could define a method framed_moduli_space(self,n)</span>
<span class="sd">    inside the class QuiverModuliSpace which returns another quiver moduli space.</span>
<span class="sd">    After all, it is itself a quiver moduli space.</span>

<span class="sd">    #TODO (Pieter) yes, I agree with this</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">betti_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="sd">&quot;&quot;&quot;Auxiliary methods:&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">extended_gcd</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the gcd and the Bezout coefficients of a list of integers.&quot;&quot;&quot;</span>
    <span class="c1"># This exists for two integers but there seems to be</span>
    <span class="c1"># no implementation for more than one.</span>
    <span class="c1"># That&#39;s astonishing.</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
        <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>