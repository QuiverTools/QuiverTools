<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>quiver.moduli - QuiverTools v0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">QuiverTools v0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">QuiverTools v0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for quiver.moduli</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations_with_replacement</span><span class="p">,</span> <span class="n">product</span>

<span class="kn">from</span> <span class="nn">sage.arith.misc</span> <span class="kn">import</span> <span class="n">bernoulli</span><span class="p">,</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">xgcd</span>
<span class="kn">from</span> <span class="nn">sage.combinat.partition</span> <span class="kn">import</span> <span class="n">Partitions</span>
<span class="kn">from</span> <span class="nn">sage.combinat.permutation</span> <span class="kn">import</span> <span class="n">Permutations</span>
<span class="kn">from</span> <span class="nn">sage.combinat.schubert_polynomial</span> <span class="kn">import</span> <span class="n">SchubertPolynomialRing</span>
<span class="kn">from</span> <span class="nn">sage.combinat.sf.sf</span> <span class="kn">import</span> <span class="n">SymmetricFunctions</span>
<span class="kn">from</span> <span class="nn">sage.matrix.constructor</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="kn">from</span> <span class="nn">sage.misc.misc_c</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>
<span class="kn">from</span> <span class="nn">sage.rings.function_field.constructor</span> <span class="kn">import</span> <span class="n">FunctionField</span>
<span class="kn">from</span> <span class="nn">sage.rings.infinity</span> <span class="kn">import</span> <span class="n">Infinity</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer_ring</span> <span class="kn">import</span> <span class="n">ZZ</span>
<span class="kn">from</span> <span class="nn">sage.rings.polynomial.polynomial_ring_constructor</span> <span class="kn">import</span> <span class="n">PolynomialRing</span>
<span class="kn">from</span> <span class="nn">sage.rings.polynomial.term_order</span> <span class="kn">import</span> <span class="n">TermOrder</span>
<span class="kn">from</span> <span class="nn">sage.rings.quotient_ring</span> <span class="kn">import</span> <span class="n">QuotientRing</span>
<span class="kn">from</span> <span class="nn">sage.rings.rational_field</span> <span class="kn">import</span> <span class="n">QQ</span>

<span class="kn">from</span> <span class="nn">quiver</span> <span class="kn">import</span> <span class="n">Quiver</span>

<span class="sd">&quot;&quot;&quot;Defines how permutations are multiplied.&quot;&quot;&quot;</span>
<span class="n">Permutations</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">mult</span><span class="o">=</span><span class="s2">&quot;r2l&quot;</span><span class="p">)</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">a brainstorm</span>

<span class="sd">What about an abstract base class QuiverModuli which deals with all the things common to moduli spaces and moduli stacks?</span>
<span class="sd">There&#39;d be abstract methods for things like dimension.</span>

<span class="sd">Then we&#39;d have implementations in</span>
<span class="sd">- QuiverModuliSpace</span>
<span class="sd">- QuiverModuliStack</span>

<span class="sd">This avoids the ugly distinction between the two.</span>
<span class="sd">The stack would also allow _not_ specifying stable or semistable,</span>
<span class="sd">whereas for the quiver moduli space this is a necessity.</span>


<span class="sd">Something like enumerating Harder-Narasimhan strata is then a method of QuiverModuliStack?</span>

<span class="sd">Something like computing Betti numbers is then only implemented for QuiverModuliSpace.</span>

<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="QuiverModuli">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuli</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">_is_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">condition</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;semistable&quot;</span><span class="p">,</span> <span class="s2">&quot;stable&quot;</span><span class="p">]</span>
        <span class="c1"># TODO this effectivity condition needs to be documented, and maybe be part of Quiver?</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">denom</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">simple_root</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span> <span class="o">=</span> <span class="n">Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span> <span class="o">=</span> <span class="n">denom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">=</span> <span class="n">condition</span>

    <span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

    <span class="k">def</span> <span class="nf">dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

    <span class="k">def</span> <span class="nf">stability_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

    <span class="k">def</span> <span class="nf">denominator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span>

    <span class="k">def</span> <span class="nf">is_nonempty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    HN business</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.all_harder_narasimhan_types">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_harder_narasimhan_types">[docs]</a>
    <span class="k">def</span> <span class="nf">all_harder_narasimhan_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all HN types.</span>

<span class="sd">        A Harder--Narasimhan (HN) type of :math:`d` with respect to :math:`\theta`</span>
<span class="sd">        is a sequence :math:`d^* = (d^1,...,d^s)` of dimension vectors such that</span>

<span class="sd">        - :math:`d^1 + ... + d^s = d`</span>
<span class="sd">        - :math:`\mu_{\theta}(d^1) &gt; ... &gt; \mu_{\theta}(d^s)`</span>
<span class="sd">        - Every :math:`d^k` is :math:`\theta`-semi-stable.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``proper`` -- (default: False) whether to exclude the HN type corresponding to the stable locus</span>

<span class="sd">        - ``sorted`` -- (default: False) whether to sort the HN-types according to the given slope</span>

<span class="sd">        OUTPUT: list of tuples of dimension vectors encoding HN-types</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3])</span>
<span class="sd">            sage: X.all_harder_narasimhan_types()</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>
<span class="sd">            sage: X.all_harder_narasimhan_types(proper=True)</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1))]</span>
<span class="sd">            sage: d = [2, 3]</span>
<span class="sd">            sage: theta = -Q.canonical_stability_parameter(d)</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: Y.all_harder_narasimhan_types()</span>
<span class="sd">            [((0, 3), (2, 0))]</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(2, 3, 4)</span>
<span class="sd">            sage: d = [2, 3, 2]</span>
<span class="sd">            sage: Z = QuiverModuliSpace(Q, [2, 3, 2])</span>
<span class="sd">            sage: Z.all_harder_narasimhan_types()</span>
<span class="sd">            [((0, 1, 0), (1, 2, 1), (1, 0, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 1, 0), (2, 2, 2)),</span>
<span class="sd">             ((0, 2, 0), (1, 1, 1), (1, 0, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 2, 0), (2, 1, 2)),</span>
<span class="sd">             ((0, 3, 0), (2, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((0, 3, 0), (2, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 1, 0), (1, 2, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 2, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (0, 3, 1), (1, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 1, 0), (0, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 1, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((1, 0, 0), (1, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 0, 0), (1, 3, 2)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 1, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 1, 0), (0, 2, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (0, 2, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 1, 0), (1, 0, 1), (0, 2, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 1, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 1, 0), (1, 2, 2)),</span>
<span class="sd">             ((1, 2, 0), (0, 1, 0), (1, 0, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 2, 0), (0, 1, 0), (1, 0, 2)),</span>
<span class="sd">             ((1, 2, 0), (1, 0, 1), (0, 1, 1)),</span>
<span class="sd">             ((1, 2, 0), (1, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((1, 2, 0), (1, 1, 2)),</span>
<span class="sd">             ((1, 2, 1), (1, 1, 1)),</span>
<span class="sd">             ((1, 3, 1), (1, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 0, 0), (0, 3, 2)),</span>
<span class="sd">             ((2, 0, 1), (0, 3, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 1, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 1, 0), (0, 2, 2)),</span>
<span class="sd">             ((2, 1, 1), (0, 2, 1)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 2, 0), (0, 1, 2)),</span>
<span class="sd">             ((2, 2, 1), (0, 1, 1)),</span>
<span class="sd">             ((2, 3, 0), (0, 0, 2)),</span>
<span class="sd">             ((2, 3, 1), (0, 0, 1)),</span>
<span class="sd">             ((2, 3, 2),)]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>

        <span class="n">all_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">all_hn_types</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="nb">sorted</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">proper</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d</span><span class="p">,)</span> <span class="ow">in</span> <span class="n">all_types</span><span class="p">:</span>
            <span class="n">all_types</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">all_types</span></div>


<div class="viewcode-block" id="QuiverModuli.is_harder_narasimhan_type">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_harder_narasimhan_type">[docs]</a>
    <span class="k">def</span> <span class="nf">is_harder_narasimhan_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if ``dstar`` is a HN type.</span>

<span class="sd">        A Harder--Narasimhan (HN) type of `d` with respect to :math:`\theta`</span>
<span class="sd">        is a sequence :math:`d^* = (d^1,...,d^s)` of dimension vectors such that</span>

<span class="sd">        - :math:`d^1 + ... + d^s = d`</span>
<span class="sd">        - :math:`\mu_{\theta}(d^1) &gt; ... &gt; \mu_{\theta}(d^s)`</span>
<span class="sd">        - Every :math:`d^k` is theta-semi-stable.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``dstar`` -- list of vectors of Ints</span>

<span class="sd">        OUTPUT: statement truth value as Bool</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], [1, 0])</span>
<span class="sd">            sage: HNs = X.all_harder_narasimhan_types()</span>
<span class="sd">            sage: all(X.is_harder_narasimhan_type(dstar) for dstar in HNs)</span>
<span class="sd">            True</span>
<span class="sd">            sage: dstar = [[1, 0], [1, 0], [0, 3]]</span>
<span class="sd">            sage: X.is_harder_narasimhan_type(dstar)</span>
<span class="sd">            False</span>
<span class="sd">            sage: X.is_harder_narasimhan_type([Q.zero_vector()])</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">dstar</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">di</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">di</span><span class="p">),</span> <span class="n">dstar</span><span class="p">))</span>

        <span class="c1"># first condition: sum to dimension vector</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dstar</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># second condition: decreasing slopes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="o">&gt;</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dstar</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="QuiverModuli.codimension_of_harder_narasimhan_stratum">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_of_harder_narasimhan_stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of the HN stratum of ``dstar``</span>
<span class="sd">        inside the representation variety.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``dstar`` -- list of vectors of Ints</span>
<span class="sd">        - ``secure`` -- (default: False): Bool</span>

<span class="sd">        OUTPUT: codimension as Int</span>
<span class="sd">        # TODO</span>
<span class="sd">        # It checks for dstar to be a HN type iff secure == True. This check is slow.</span>
<span class="sd">        # Be sure to be dealing with a HN type if you call it with secure == False. This is fast but yields nonsense, if dstar is not a HN type.</span>

<span class="sd">        The codimension of the HN stratum of :math:`d^* = (d^1,...,d^s)` is given by</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            - sum_{k &lt; l} &lt;d^k,d^l&gt;</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([1,0])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: hn = X.all_harder_narasimhan_types(); hn</span>
<span class="sd">            [((1, 0), (1, 1), (0, 2)),</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)),</span>
<span class="sd">             ((1, 0), (1, 3)),</span>
<span class="sd">             ((1, 1), (1, 2)),</span>
<span class="sd">             ((2, 0), (0, 3)),</span>
<span class="sd">             ((2, 1), (0, 2)),</span>
<span class="sd">             ((2, 2), (0, 1)),</span>
<span class="sd">             ((2, 3),)]</span>
<span class="sd">            sage: [X.codimension_of_harder_narasimhan_stratum(dstar) for dstar in hn]</span>
<span class="sd">            [12, 9, 8, 3, 18, 10, 4, 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_is_dimension_vector</span><span class="p">(</span><span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dstar</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_harder_narasimhan_type</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dstar</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dstar</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dstar</span><span class="p">))</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.codimension_unstable_locus">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_unstable_locus">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_unstable_locus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of the unstable locus</span>
<span class="sd">        inside the representation variety.</span>

<span class="sd">        OUTPUT: codimension as Int</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], [1, 0])</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            3</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: Q = ThreeVertexQuiver(1,6,1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 6, 6])</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            1</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], [1, 0])</span>
<span class="sd">            sage: X.codimension_unstable_locus()</span>
<span class="sd">            0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># note that while the HN types and strata depend on the denominator</span>
        <span class="c1"># the list of all their codimensions does not</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dstar</span> <span class="ow">in</span> <span class="n">HNs</span>
        <span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Luna</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.all_luna_types">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_luna_types">[docs]</a>
    <span class="k">def</span> <span class="nf">all_luna_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the unordered list of all Luna types of d for theta.</span>

<span class="sd">        OUTPUT: list of tuples containing Int-vector and Int</span>

<span class="sd">        A Luna type of d for theta is an unordered sequence (i.e. multiset)</span>
<span class="sd">        :math:`((d^1,m_1),...,(d^s,m_s))` of dimension vectors</span>
<span class="sd">        :math:`d^k` and positive integers :math:`m_k` such that</span>
<span class="sd">        </span>
<span class="sd">        - :math:`m_1d^1 + ... + m_sd^s = d`</span>
<span class="sd">        - :math:`\mu_{\theta}(d^k) = \mu_{\theta}(d)`</span>
<span class="sd">        - All :math:`d^k` admit a :math:`\theta`-stable representation</span>

<span class="sd">        Example: Suppose that `d = 3e` and `e, 2e, d = 3e`</span>
<span class="sd">        are the only stable subdimension vectors.</span>
<span class="sd">        Then the Luna types are</span>
<span class="sd">        </span>
<span class="sd">        .. MATH::</span>

<span class="sd">            \begin{aligned}</span>
<span class="sd">                ((3e,1)) \\</span>
<span class="sd">                ((2e,1),(e,1))\\</span>
<span class="sd">                ((e,3))\\</span>
<span class="sd">                ((e,2),(e,1))\\</span>
<span class="sd">                ((e,1),(e,1),(e,1)).</span>
<span class="sd">            \end{aligned}</span>

<span class="sd">        We implement it as follows.</span>
<span class="sd">        </span>
<span class="sd">        A Luna type for us is a dictionary</span>
<span class="sd">        ``{d^1: p_1^1,..., d^s: p_s^1,..., d_s: p_s^t}``</span>
<span class="sd">        of dimension vectors d^k and non-empty partitions p^k such that</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            |p_1^1|d^1 + ... + |p_s^t|d^s = d</span>

<span class="sd">        So in the above example, the Luna types are::</span>

<span class="sd">            {3e: [1]}</span>
<span class="sd">            {2e: [1], e: [1]}</span>
<span class="sd">            {e: [3]}</span>
<span class="sd">            {e: [2, 1]}</span>
<span class="sd">            {e: [1, 1, 1]}</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([3,3]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(1, 1): [3]}, {(1, 1): [2, 1]}, {(1, 1): [1, 1, 1]}]</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([3,3])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(3, 3): [1]},</span>
<span class="sd">             {(1, 1): [1], (2, 2): [1]},</span>
<span class="sd">             {(1, 1): [3]},</span>
<span class="sd">             {(1, 1): [2, 1]},</span>
<span class="sd">             {(1, 1): [1, 1, 1]}]</span>

<span class="sd">        The zero vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([0,0]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.all_luna_types()</span>
<span class="sd">            [{(0, 0): [1]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="c1"># Q.zero_vector() can&#39;t be hashed a priori</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">())</span>
            <span class="k">return</span> <span class="p">[{</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}]</span>

        <span class="n">same_slope</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">same_slope</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
                <span class="n">same_slope</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">same_slope</span><span class="p">))</span><span class="o">.</span><span class="n">ceil</span><span class="p">()</span>
        <span class="n">luna_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">same_slope</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                    <span class="c1"># from tau we build all possible Luna types</span>
                    <span class="n">partial</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">taui</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tau</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">taui</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">partial</span><span class="p">[</span><span class="n">taui</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">partial</span><span class="p">[</span><span class="n">taui</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="c1"># partial has the form</span>
                    <span class="c1"># {d^1: Partitions(p^1), ..., d^s: Partitions(p^s)}</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">partial</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">partial</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>

                    <span class="n">new_types</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">partial</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">values</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">partial</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                    <span class="p">]</span>
                    <span class="n">luna_types</span> <span class="o">+=</span> <span class="n">new_types</span>
        <span class="k">return</span> <span class="n">luna_types</span></div>


<div class="viewcode-block" id="QuiverModuli.is_luna_type">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_luna_type">[docs]</a>
    <span class="k">def</span> <span class="nf">is_luna_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if tau is a Luna type for theta.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- dictionary with dimension vectors as keys and lists of ints as values</span>

<span class="sd">        OUTPUT: whether ``tau`` is a Luna type.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([3,3]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: l = X.all_luna_types()</span>
<span class="sd">            sage: all(X.is_luna_type(tau) for tau in l)</span>
<span class="sd">            True</span>

<span class="sd">        The 3-Kronecker quiver with zero vector::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([0,0]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: d.set_immutable()</span>
<span class="sd">            sage: X.is_luna_type({d: [1]})</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">d</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="c1"># Q.zero_vector() can&#39;t be hashed a priori</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_vector</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">tau</span> <span class="o">==</span> <span class="p">{</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.dimension_of_luna_stratum">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.dimension_of_luna_stratum">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension_of_luna_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the Luna stratum :math:`S_\tau`.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- list of tuples</span>
<span class="sd">        - ``secure`` -- Bool</span>

<span class="sd">        OUTPUT: Dimension as Int</span>

<span class="sd">        The dimension of the Luna stratum of</span>
<span class="sd">        ``tau = {d^1: p^1,...,d^s: p^s}`` is</span>
<span class="sd">        :math:`\sum_k l(p^k)(1 - &lt;\langle d^k,d^k\rangle)`,</span>
<span class="sd">        where for a partition :math:`p = (n_1,...,n_l)`,</span>
<span class="sd">        the length `l(p)` is `l`, i.e. the number of summands.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([2,2]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: L = X.all_luna_types(); L</span>
<span class="sd">            [{(1, 1): [2]}, {(1, 1): [1, 1]}]</span>
<span class="sd">            sage: [X.dimension_of_luna_stratum(tau) for tau in L]</span>
<span class="sd">            [1, 2]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_luna_type</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">dn</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">dn</span><span class="p">))</span> <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="QuiverModuli.local_quiver_setting">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.local_quiver_setting">[docs]</a>
    <span class="k">def</span> <span class="nf">local_quiver_setting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local quiver and dimension vector for the given Luna type.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau`` -- list of tuples</span>
<span class="sd">        - ``secure`` -- Bool</span>

<span class="sd">        OUTPUT: tuple consisting of a Quiver object and a vector</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,2])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: L = X.all_luna_types(); L</span>
<span class="sd">            [{(2, 2): [1]}, {(1, 1): [2]}, {(1, 1): [1, 1]}]</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(L[0]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix() , dloc</span>
<span class="sd">            ([4], (1))</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(L[1]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix() , dloc</span>
<span class="sd">            ([1], (2))</span>
<span class="sd">            sage: Qloc, dloc = X.local_quiver_setting(L[2]);</span>
<span class="sd">            sage: Qloc.adjacency_matrix() , dloc</span>
<span class="sd">            (</span>
<span class="sd">            [1 1]</span>
<span class="sd">            [1 1], (1, 1)</span>
<span class="sd">            )</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">secure</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_luna_type</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="c1"># a word of caution to the future maintainer: Python dictionaries</span>
        <span class="c1"># iterate over the keys in the order they were inserted. This ensures</span>
        <span class="c1"># that the following is a well-defined adjacency matrix. Python sets</span>
        <span class="c1"># DO NOT have this property.</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">generic_ext</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">eq</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">dp</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">Qloc</span> <span class="o">=</span> <span class="n">Quiver</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">dloc</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tau</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">tau</span><span class="p">[</span><span class="n">dp</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Qloc</span><span class="p">,</span> <span class="n">dloc</span></div>


    <span class="c1"># TODO: The codimension computation requires the dimension of the nullcone. This is hard, it turns out. It can be done with the Hesselink stratification, but I wasn&#39;t willing to go thourgh Lieven&#39;s treatment of this.</span>
    <span class="k">def</span> <span class="nf">_codimension_inverse_image_luna_stratum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of :math:`\pi^{-1}(S_{tau})`</span>
<span class="sd">        inside `R(Q,d)` where :math:`\pi: R(Q,d)^{\theta-sst} --&gt; M^{\theta-sst}(Q,d)`</span>
<span class="sd">        is the semistable quotient map.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``tau``: list of tuples</span>

<span class="sd">        OUTPUT: codimension as Int</span>

<span class="sd">        For ``tau = {d^1: p^1,...,d^s: p^s}``</span>
<span class="sd">        the codimension of :math:`\pi^{-1}(S_{tau})` is</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            -\langle d,d \rangle + \sum_{k=1}^s</span>
<span class="sd">            (\langle d^k,d^k\rangle - l(p^k) + ||p^k||^2) -</span>
<span class="sd">            \mathrm{dim} N(Q_{tau}, d_{tau}),</span>

<span class="sd">        where for a partition :math:`p = (n_1,...,n_l)`, we define</span>
<span class="sd">        :math:`||p||^2 = \sum_v n_v^2`</span>
<span class="sd">        and :math:`N(Q_{tau}, d_{tau})` is the nullcone of the local quiver setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="n">Qtau</span><span class="p">,</span> <span class="n">dtau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_quiver_setting</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dimNull</span> <span class="o">=</span> <span class="n">Qtau</span><span class="o">.</span><span class="n">dimension_nullcone</span><span class="p">(</span><span class="n">dtau</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">nkv</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">nkv</span> <span class="ow">in</span> <span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">tau</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="o">-</span> <span class="n">dimNull</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QuiverModuli.codimension_properly_semistable_locus">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.codimension_properly_semistable_locus">[docs]</a>
    <span class="k">def</span> <span class="nf">codimension_properly_semistable_locus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the codimension of :math:`R^{\theta-sst}(Q,d)</span>
<span class="sd">        \setminus R^{\theta-st}(Q,d)` inside :math:`R(Q,d)`.</span>

<span class="sd">        OUTPUT: codimension as Int</span>

<span class="sd">        The codimension of the properly semistable locus</span>
<span class="sd">        is the minimal codimension of the inverse image</span>
<span class="sd">        of the non-stable Luna strata.&quot;&quot;&quot;</span>

        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">()</span>
        <span class="c1"># This is the stable Luna type; remove it if it occurs</span>
        <span class="n">dstable</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">tau</span><span class="p">:</span> <span class="n">tau</span> <span class="o">!=</span> <span class="n">dstable</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_codimension_inverse_image_luna_stratum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">L</span><span class="p">])</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (Semi-)stability</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.semistable_equals_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.semistable_equals_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">semistable_equals_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether every semistable representation is stable</span>
<span class="sd">        for the given stability parameter.</span>

<span class="sd">        Every :math:`\theta`-semistable representation is</span>
<span class="sd">        :math:`\theta`-stable if and only if</span>
<span class="sd">        there are no Luna types other than (possibly) ``{d: [1]}``.</span>

<span class="sd">        OUTPUT: whether every theta-semistable representation is theta-stable</span>
<span class="sd">        for ``self._theta``</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([3,3])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.semistable_equals_stable()</span>
<span class="sd">            False</span>
<span class="sd">            sage: e = vector([2,3])</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, e, theta)</span>
<span class="sd">            sage: Y.semistable_equals_stable()</span>
<span class="sd">            True</span>

<span class="sd">        A double framed example as in our vector fields paper::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: Q = Q.framed_quiver([1, 0]).coframed_quiver([0, 0, 1])</span>
<span class="sd">            sage: d = [1, 2, 3, 1]</span>
<span class="sd">            sage: theta = [1, 300, -200, -1]</span>
<span class="sd">            sage: Q.is_theta_coprime(d, theta)</span>
<span class="sd">            False</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta)</span>
<span class="sd">            sage: X.semistable_equals_stable()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># the computation of all Luna types takes so much time</span>
        <span class="c1"># thus we should first tests if d is theta-coprime</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># this is probably the fastest way as checking theta-coprimality is fast</span>
        <span class="c1"># whereas checking for existence of a semi-stable representation is a bit slower</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allLunaTypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">()</span>
            <span class="n">genericType</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
            <span class="k">if</span> <span class="n">genericType</span> <span class="ow">in</span> <span class="n">allLunaTypes</span><span class="p">:</span>
                <span class="n">allLunaTypes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">genericType</span><span class="p">)</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">allLunaTypes</span>  <span class="c1"># This checks if the list is empty</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ample stability</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO reimplement this with HN strata computation.</span>
<div class="viewcode-block" id="QuiverModuli.is_amply_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_amply_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">is_amply_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if the dimension vector is amply stable for the stability parameter</span>

<span class="sd">        By definition, a dimension vector `d` is :math:`\theta`-amply stable if the</span>
<span class="sd">        codimension of the :math:`\theta`-semistable locus</span>
<span class="sd">        inside `R(Q,d)` is at least 2.</span>

<span class="sd">        OUTPUT: whether the data for the quiver moduli space is amply stable</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [2, 3]).is_amply_stable()</span>
<span class="sd">            True</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [2, 3], [-3, 2]).is_amply_stable()</span>
<span class="sd">            False</span>

<span class="sd">        A three-vertex example from the rigidity paper::</span>

<span class="sd">            sage: Q = ThreeVertexQuiver(1, 6, 1)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [1, 6, 6]).is_amply_stable()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">codimension_of_harder_narasimhan_stratum</span><span class="p">(</span><span class="n">dstar</span><span class="p">,</span> <span class="n">secure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dstar</span> <span class="ow">in</span> <span class="n">HNs</span>
            <span class="p">)</span>
            <span class="o">&gt;=</span> <span class="mi">2</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.is_strongly_amply_stable">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.is_strongly_amply_stable">[docs]</a>
    <span class="k">def</span> <span class="nf">is_strongly_amply_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checks if the dimension vector is strongly amply stable for the stability</span>
<span class="sd">        parameter</span>

<span class="sd">        We call `d` strongly amply stable for :math:`\theta` if</span>
<span class="sd">        :math:`\langle e,d-e\rangle \leq -2`</span>
<span class="sd">        holds for all subdimension vectors :math:`e` of :math:`d` which satisfy</span>
<span class="sd">        :math:`\mu_{\theta}(e) &gt;= \mu_{\theta}(d)`.</span>

<span class="sd">        OUTPUT: whether the data for the quiver moduli space is strongly amply stable</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: QuiverModuliSpace(Q, [2, 3]).is_strongly_amply_stable()</span>
<span class="sd">            True</span>

<span class="sd">        A 3-vertex quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = ThreeVertexQuiver(5, 1, 1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [4, 1, 4])</span>
<span class="sd">            sage: X.is_amply_stable()</span>
<span class="sd">            True</span>
<span class="sd">            sage: X.is_strongly_amply_stable()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># subdimension vectors of smaller slope</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
        <span class="n">es</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">slope</span><span class="p">,</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forget_labels</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">2</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">es</span><span class="p">)</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Methods related to Teleman quantization</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuiverModuli.harder_narasimhan_weight">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.harder_narasimhan_weight">[docs]</a>
    <span class="k">def</span> <span class="nf">harder_narasimhan_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">harder_narasimhan_type</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Teleman weight of a Harder-Narasimhan type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span>
        <span class="n">HN</span> <span class="o">=</span> <span class="n">harder_narasimhan_type</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="c1"># TODO can we make this cleaner-looking?</span>
                <span class="c1"># = unordered tuples without repetition?</span>
                <span class="p">(</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">HN</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HN</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">HN</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.all_weight_bounds">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_weight_bounds">[docs]</a>
    <span class="k">def</span> <span class="nf">all_weight_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all weights appearing in Teleman quantization.</span>

<span class="sd">        For each HN type, the 1-PS lambda acts on :math:`\det(N_{S/R}|_Z)`</span>
<span class="sd">        with a certain weight. Teleman quantization gives a numerical condition</span>
<span class="sd">        involving these weights to compute cohmology on the quotient.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``as_dict`` -- (default: False) when True it will give a dict whose keys are</span>
<span class="sd">          the HN-types and whose values are the weights</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 6-dimensional 3-Kronecker example::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: X = QuiverModuliSpace(KroneckerQuiver(3), [2, 3])</span>
<span class="sd">            sage: X.all_weight_bounds()</span>
<span class="sd">            [135, 100, 90, 15/2, 270, 100, 30]</span>
<span class="sd">            sage: X.all_weight_bounds(as_dict=True)</span>
<span class="sd">            {((1, 0), (1, 1), (0, 2)): 135,</span>
<span class="sd">             ((1, 0), (1, 2), (0, 1)): 100,</span>
<span class="sd">             ((1, 0), (1, 3)): 90,</span>
<span class="sd">             ((1, 1), (1, 2)): 15/2,</span>
<span class="sd">             ((2, 0), (0, 3)): 270,</span>
<span class="sd">             ((2, 1), (0, 2)): 100,</span>
<span class="sd">             ((2, 2), (0, 1)): 30}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is only relevant on the unstable locus</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">HN</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">harder_narasimhan_weight</span><span class="p">(</span><span class="n">HN</span><span class="p">),</span> <span class="n">HNs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">HNs</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuli.if_rigidity_inequality_holds">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.if_rigidity_inequality_holds">[docs]</a>
    <span class="k">def</span> <span class="nf">if_rigidity_inequality_holds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        OUTPUT: whether the rigidity inequality holds on the given moduli</span>

<span class="sd">        If the weights of the 1-PS lambda on :math:`\det(N_{S/R}|_Z)` for each HN type</span>
<span class="sd">        are all strictly larger than the weights of the tensors of the universal bundles</span>
<span class="sd">        :math:`U_i^\vee \otimes U_j`,</span>
<span class="sd">        then the resulting moduli space is infinitesimally rigid.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: X = QuiverModuliSpace(KroneckerQuiver(3), [2, 3])</span>
<span class="sd">            sage: X.if_rigidity_inequality_holds()</span>
<span class="sd">            True</span>
<span class="sd">            sage: X = QuiverModuliSpace(ThreeVertexQuiver(1, 6, 1), [1, 6, 6])</span>
<span class="sd">            sage: X.if_rigidity_inequality_holds()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denominator</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_weight_bounds</span><span class="p">()</span>

        <span class="c1"># we compute the maximum weight of the tensors of the universal bundles</span>
        <span class="c1"># this is only relevant on the unstable locus</span>
        <span class="n">HNs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_harder_narasimhan_types</span><span class="p">(</span><span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">tensor_weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">HN</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">HN</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">),</span>
                <span class="n">HNs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tensor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">HNs</span><span class="p">)))</span></div>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tautological relations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_all_forbidden_subdimension_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all forbidden subdimension vectors</span>

<span class="sd">        These are the dimension vectors `d&#39;` of d for which</span>

<span class="sd">        - :math:`\mu_{\theta}(d&#39;) &gt; \mu_{\theta}(d)` (in the semistable case)</span>
<span class="sd">        - or for which :math:`\mu_{\theta}(d&#39;) &gt;= \mu_{\theta}(d)` (in the stable case).</span>

<span class="sd">        OUTPUT: list of forbidden subdimension vectors vectors</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X._all_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2)]</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X._all_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>

        <span class="n">es</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">proper</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nonzero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># TODO need for denominator?</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">slope</span><span class="p">,</span> <span class="n">es</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">slope</span><span class="p">,</span> <span class="n">es</span><span class="p">))</span>

<div class="viewcode-block" id="QuiverModuli.all_minimal_forbidden_subdimension_vectors">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.all_minimal_forbidden_subdimension_vectors">[docs]</a>
    <span class="k">def</span> <span class="nf">all_minimal_forbidden_subdimension_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the list of all `minimal` forbidden subdimension vectors</span>

<span class="sd">        Minimality is with respect to the partial order `e &lt;&lt; d` which means</span>
<span class="sd">        :math:`e_i \leq d_i` for every source `i`, :math:`e_j \geq d_j`</span>
<span class="sd">        for every sink `j`, and :math:`e_k = d_k` for every vertex which is neither</span>
<span class="sd">        a source nor a sink. See also :meth:`Quiver.division_order`.</span>

<span class="sd">        OUTPUT: list of minimal forbidden dimension vectors</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.all_minimal_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 0), (2, 1), (3, 2)]</span>
<span class="sd">            sage: Y = QuiverModuliSpace(Q, [3, 3], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: Y.all_minimal_forbidden_subdimension_vectors()</span>
<span class="sd">            [(1, 1), (2, 2)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span>

        <span class="n">forbidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_forbidden_subdimension_vectors</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">is_minimal</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">division_order</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">e</span><span class="p">,</span> <span class="n">forbidden</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_minimal</span><span class="p">,</span> <span class="n">forbidden</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="nf">__tautological_presentation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the tautological relations in Chern classes</span>
<span class="sd">        (if ``inRoots == False``) or in Chern roots.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``inRoots`` -- Bool</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>
<span class="sd">        - ``chernRoots`` -- list of Strings</span>

<span class="sd">        OUTPUT: dict</span>

<span class="sd">        # TODO</span>
<span class="sd">        Explanation ...</span>

<span class="sd">        Notation for explanations:</span>
<span class="sd">        G = G_d = prod_{i in Q_0} GL_{d_i}</span>
<span class="sd">        T = maximal torus of diagonal matrices</span>
<span class="sd">        PG = G/G_m</span>
<span class="sd">        PT = T/G_m maximal torus of PT</span>
<span class="sd">        W = Weyl group of T in G = Weyl group of PT in PG</span>
<span class="sd">          = prod_{i in Q_0} S_{d_i}</span>
<span class="sd">        R = bigoplus_{a in Q_1} Hom(k^{d_{s(a)}},k^{d_{t(a)}})</span>
<span class="sd">        R^{sst}, R^{st} semi-stable/stable locus</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        # TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">chernRoots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernRoots</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;t</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">chernRoots</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns generator(R, i, r) = t{i+1}_{r+1}.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]))</span>

<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generators of the tautological ideal regarded upstairs, i.e. in A*([R/T]).</span>
<span class="sd">        For a forbidden subdimension vector e of d, the forbidden polynomial in Chern</span>
<span class="sd">        roots is given by :math:`\prod_{a: i \to j} \prod_{r=1}^{e_i}</span>
<span class="sd">        \prod_{s=e_j+1}^{d_j} (tj_s - ti_r) =</span>
<span class="sd">        \prod_{i,j} \prod_{r=1}^{e_i} \prod_{s=e_j+1}^{d_j} (tj_s - ti_r)^{a_{ij}}.&quot;&quot;&quot;</span>
        <span class="n">forbiddenPolynomials</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="p">(</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
                            <span class="o">**</span> <span class="n">Q</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_minimal_forbidden_subdimension_vectors</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">inRoots</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;ParentRing&quot;</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
                <span class="s2">&quot;Generators&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
                <span class="s2">&quot;Relations&quot;</span><span class="p">:</span> <span class="n">forbiddenPolynomials</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;delta is the discriminant&quot;&quot;&quot;</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;longest is the longest Weyl group element</span>
<span class="sd">            when regarding W as a subgroup of S_{sum d_i}&quot;&quot;&quot;</span>
            <span class="n">longest</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">longest</span> <span class="o">=</span> <span class="n">longest</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">bruhat_smaller</span><span class="o">=</span><span class="n">longest</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">antisymmetrization</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;The antisymmetrization of f is the symmetrization</span>
<span class="sd">                divided by the discriminant.&quot;&quot;&quot;</span>

                <span class="c1"># I don&#39;t want to define W and delta here but globally because then we need to</span>
                <span class="c1"># compute it just once. That&#39;s probably a bit faster.</span>
                <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">R</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">ngens</span><span class="p">())})</span>

                <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="n">permute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">W</span><span class="p">)</span> <span class="o">//</span> <span class="n">delta</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Schubert basis of A^*([R/T]) over A^*([R/G])&quot;&quot;&quot;</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">SchubertPolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
            <span class="n">supp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())))</span>

            <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Permutations</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>

            <span class="n">Bprime</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">ngens</span><span class="p">())],</span> <span class="n">R</span>
                    <span class="p">)(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">supp</span>
            <span class="p">]</span>

            <span class="c1"># TODO is this not something already implemented? if not, explain what it does!</span>
            <span class="k">def</span> <span class="nf">product_lists</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="n">product_lists</span><span class="p">([</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="n">l</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">schubert</span> <span class="o">=</span> <span class="n">product_lists</span><span class="p">(</span><span class="n">Bprime</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Define A = A*([R/G]).&quot;&quot;&quot;</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">chernClasses</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">TermOrder</span><span class="p">(</span><span class="s2">&quot;wdegrevlex&quot;</span><span class="p">,</span> <span class="n">degrees</span><span class="p">))</span>

            <span class="n">E</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;The Chern classes of U_i on [R/G] are the elementary symmetric functions</span>
<span class="sd">            in the Chern roots ti_1,...,ti_{d_i}.&quot;&quot;&quot;</span>
            <span class="n">elementarySymmetric</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()):</span>
                <span class="n">elementarySymmetric</span> <span class="o">=</span> <span class="n">elementarySymmetric</span> <span class="o">+</span> <span class="p">[</span>
                    <span class="n">E</span><span class="p">([</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">alphabet</span><span class="o">=</span><span class="p">[</span><span class="n">generator</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">]</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Map xi_r to the r-th elementary symmetric function</span>
<span class="sd">            in ti_1,...,ti_{d_i}.&quot;&quot;&quot;</span>
            <span class="n">inclusion</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">elementarySymmetric</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;Tautological relations in Chern classes.&quot;&quot;&quot;</span>
            <span class="n">tautological</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">antisymmetrization</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">schubert</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">forbiddenPolynomials</span>
            <span class="p">]</span>
            <span class="n">tautological</span> <span class="o">=</span> <span class="p">[</span><span class="n">inclusion</span><span class="o">.</span><span class="n">inverse_image</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">tautological</span><span class="p">]</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;ParentRing&quot;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span>
                <span class="s2">&quot;Generators&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">generator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
                <span class="s2">&quot;Relations&quot;</span><span class="p">:</span> <span class="n">tautological</span><span class="p">,</span>
            <span class="p">}</span>

<div class="viewcode-block" id="QuiverModuli.tautological_relations">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuli.tautological_relations">[docs]</a>
    <span class="k">def</span> <span class="nf">tautological_relations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tautological relations in</span>
<span class="sd">        Chern classes (if inRoots == False) or in Chern roots.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``inRoots`` -- Bool</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>
<span class="sd">        - ``chernRoots`` -- list of Strings</span>

<span class="sd">        OUTPUT: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="n">inRoots</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">,</span> <span class="n">chernRoots</span><span class="o">=</span><span class="n">chernRoots</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span></div>


    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>



<div class="viewcode-block" id="QuiverModuliSpace">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuliSpace</span><span class="p">(</span><span class="n">QuiverModuli</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
        <span class="n">QuiverModuli</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">Q</span><span class="p">,</span>
            <span class="n">d</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
            <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">,</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;A &quot;</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>
            <span class="o">+</span> <span class="s2">&quot; quiver moduli space with:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;Q = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;d = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;theta = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliSpace.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the moduli space :math:`M^{\theta-(s)st}(Q,d)`.</span>

<span class="sd">        This involves several cases:</span>

<span class="sd">        - If there are :math:`\theta`-stable representations then</span>
<span class="sd">          :math:`\mathrm{dim} M^{\theta-sst}(Q,d) =</span>
<span class="sd">          M^{\theta-st}(Q,d) = 1 - \langle d,d\rangle`;</span>
<span class="sd">        - if there are no :math:`\theta`-stable representations then</span>
<span class="sd">          :math:`\mathrm{dim} M^{\theta-st}(Q,d) = -\infty` by convention,</span>
<span class="sd">          and we define :math:`\mathrm{dim} M^{\theta-sst} =</span>
<span class="sd">          \mathrm{max}_{\tau} \{\mathrm{dim} S_{\tau}\}`,</span>
<span class="sd">          the maximum of the dimension of all Luna strata.</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        The A2-quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(1)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(2)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            1</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            1</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], [1, -1], condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 2], [1, -1], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            2</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3], condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            6</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [3, 3],condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            10</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 3],condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            0</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 4],condition=&quot;stable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 4],condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.dimension()</span>
<span class="sd">            -Infinity</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if there are stable representations then both the stable and</span>
        <span class="c1"># the semi-stable moduli space have dimension `1-&lt;d,d&gt;`</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="c1"># stable locus is empty</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span>

        <span class="c1"># we care about the semistable locus</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="c1"># in this case the dimension is given by</span>
            <span class="c1"># the maximum of the dimensions of the Luna strata</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dimension_of_luna_stratum</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_luna_types</span><span class="p">()</span>
            <span class="p">)</span>

        <span class="c1"># semistable locus is also empty</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.poincare_polynomial">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.poincare_polynomial">[docs]</a>
    <span class="k">def</span> <span class="nf">poincare_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Poincare polynomial of the moduli space.</span>

<span class="sd">        OUTPUT: polynomial in one variable</span>
<span class="sd">        # TODO allow a user-supplied ring?</span>

<span class="sd">        The Poincare polynomial is defined as</span>

<span class="sd">        .. MATH::</span>
<span class="sd">            P_X(q) = \sum_{i \geq 0} (-1)^i \mathrm{dim} H^i(X;\mathbb{C}) q^{i/2}.</span>

<span class="sd">        For a quiver moduli space whose dimension vector is</span>
<span class="sd">        :math:`\theta`-coprime, the odd cohomology vanishes</span>
<span class="sd">        and this is a Polynomial in :math:`q`.</span>
<span class="sd">        We use Cor. 6.9 in Reineke&#39;s Harder--Narasimhan paper to compute it.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some Kronecker quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = KroneckerQuiver()</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1])</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q + 1</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [2, 3])</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q^6 + q^5 + 3*q^4 + 3*q^3 + 3*q^2 + q + 1</span>
<span class="sd">            sage: Q = SubspaceQuiver(5)</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, [1, 1, 1, 1, 1, 2])</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q^2 + 5*q + 1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">QuiverModuliStack</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">motive</span><span class="p">())</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.betti_numbers">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.betti_numbers">[docs]</a>
    <span class="k">def</span> <span class="nf">betti_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Betti numbers of the moduli space.</span>

<span class="sd">        OUTPUT: List of Ints</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Some Kronecker quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([1,1]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.poincare_polynomial()</span>
<span class="sd">            q + 1</span>
<span class="sd">            sage: X.betti_numbers()</span>
<span class="sd">            [1, 0, 1]</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.betti_numbers()</span>
<span class="sd">            [1, 0, 1, 0, 3, 0, 3, 0, 3, 0, 1, 0, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;q&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="c1"># p is the prime place of the DVR associated with v</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">zeros</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">ext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poincare_polynomial</span><span class="p">())</span>
        <span class="n">betti</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="n">v</span>
            <span class="n">betti</span> <span class="o">=</span> <span class="n">betti</span> <span class="o">+</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">betti</span></div>


    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># if theta-coprime then you can shortcut everything</span>
        <span class="c1"># if theta != 0 reduce to theta = 0 using https://mathscinet.ams.org/mathscinet-getitem?mr=1972892 (Adriaenssens--Le Bruyn)</span>
        <span class="c1"># if theta = 0, then use https://mathscinet.ams.org/mathscinet-getitem?mr=1929191 (Bocklandt)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_projective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="QuiverModuliSpace.picard_rank">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.picard_rank">[docs]</a>
    <span class="k">def</span> <span class="nf">picard_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the Picard rank of the moduli space for known cases.&quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="c1"># TODO requires smooth and projective?</span>

        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_amply_stable</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO if smooth: compute the Betti numbers and return b_2</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.index">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the index of the moduli space for known cases,</span>
<span class="sd">        i.e., the largest integer dividing the canonical divisor in Pic.&quot;&quot;&quot;</span>
        <span class="c1"># TODO this should really be a check for theta belonging to the canonical chamber, rather than being equal to the canonical stability.</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="c1"># TODO at the very least check for multiple of canonical</span>
            <span class="n">theta</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_amply_stable</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># TODO what if theta is rescaled?</span>
            <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">_to_vector</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">mukai_inequality_holds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO ample stability for the canonical stability parameter should be an attribute of the object, so that it is only computed once. Verbatim for many other attributes.</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">picard_rank</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliSpace.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Chow ring of the moduli space.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``chi`` -- vector of Ints</span>
<span class="sd">        - ``chernClasses`` -- list of Strings</span>

<span class="sd">        OUTPUT: ring</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = KroneckerQuiver(), vector([1,1]), vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([1,0])</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1], [x1_1]]</span>


<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([3,-2])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,1])</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1],</span>
<span class="sd">            [x1_1],</span>
<span class="sd">            [x0_2, x1_1^2, x1_2],</span>
<span class="sd">            [x1_1^3, x1_1*x1_2, x1_3],</span>
<span class="sd">            [x1_1^2*x1_2, x1_2^2, x1_1*x1_3],</span>
<span class="sd">            [x1_2*x1_3],</span>
<span class="sd">            [x1_3^2]]</span>

<span class="sd">        The 5-subspaces quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d = SubspaceQuiver(5), vector([1,1,1,1,1,2])</span>
<span class="sd">            sage: theta = vector([2,2,2,2,2,-5])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,-1,-1,-1,-1,3])</span>
<span class="sd">            sage: A = X.chow_ring(chi=chi)</span>
<span class="sd">            sage: I = A.defining_ideal()</span>
<span class="sd">            sage: [I.normal_basis(i) for i in range(X.dimension()+1)]</span>
<span class="sd">            [[1], [x1_1, x2_1, x3_1, x4_1, x5_1], [x5_2]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>

        <span class="c1"># This implementation only works if d is theta-coprime</span>
        <span class="c1"># which implies that d is indivisible.</span>
        <span class="k">assert</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_theta_coprime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_QuiverModuli__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">rels</span> <span class="o">=</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;ParentRing&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Generators&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">chi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># TODO assert that chi has integer entries.</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure that chi has weight one, i.e.,</span>
<span class="sd">        provides a retraction for X*(PG) --&gt; X*(G).&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">chi</span> <span class="o">*</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="n">I</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">rels</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">chi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">generator</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]))</span>

        <span class="k">return</span> <span class="n">QuotientRing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.chern_class_line_bundle">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chern_class_line_bundle">[docs]</a>
    <span class="k">def</span> <span class="nf">chern_class_line_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first Chern class of the line bundle</span>
<span class="sd">        :math:`L(\eta) = \bigotimes_{i \in Q_0} \det(U_i)^{-\eta_i}`,</span>
<span class="sd">        where :math:`\eta` is a character of :math:`PG_d`.&quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">([</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.chern_character_line_bundle">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.chern_character_line_bundle">[docs]</a>
    <span class="k">def</span> <span class="nf">chern_character_line_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Chern character of L(eta).</span>

<span class="sd">        The Chern character of a line bundle `L` with first Chern class `x`</span>
<span class="sd">        is given by :math:`e^x = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \dots`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chern_class_line_bundle</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.total_chern_class_universal">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.total_chern_class_universal">[docs]</a>
    <span class="k">def</span> <span class="nf">total_chern_class_universal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives the total Chern class of the universal bundle U_i(chi).&quot;&quot;&quot;</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.point_class">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.point_class">[docs]</a>
    <span class="k">def</span> <span class="nf">point_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the point class as an expression in Chern classes of the</span>
<span class="sd">        :math:`U_i` (``chi``).</span>

<span class="sd">        The point class is given as the homogeneous component of degree</span>
<span class="sd">        :math:`\mathrm{dim} X` of the expression</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            \prod_{a \in Q_1} c(U_{t(a)})^{d_{s(a)}} / (\prod_{i \in Q_0} c(U_i)^{d_i})</span>

<span class="sd">        EXAMPLES</span>

<span class="sd">        :math:`\mathbb{P}^7` as a quiver moduli space</span>
<span class="sd">        of a generalized Kronecker quiver::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(8)</span>
<span class="sd">            sage: d = vector([1,1])</span>
<span class="sd">            sage: theta = vector([1,-1])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([1,0])</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;o&#39;,&#39;h&#39;])</span>
<span class="sd">            h^7</span>

<span class="sd">        Our favorite 6-fold::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = GeneralizedKroneckerQuiver(3)</span>
<span class="sd">            sage: d = vector([2,3])</span>
<span class="sd">            sage: theta = vector([3,-2])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,1])</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;x1&#39;,&#39;x2&#39;,&#39;y1&#39;,&#39;y2&#39;,&#39;y3&#39;])</span>
<span class="sd">            y3^2</span>

<span class="sd">        A moduli space of the 5-subspaces quiver;</span>
<span class="sd">        it agrees with the blow-up of :math:`\mathbb{P}^2` in 4 points</span>
<span class="sd">        in general position::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q = SubspaceQuiver(5)</span>
<span class="sd">            sage: d = vector([1,1,1,1,1,2])</span>
<span class="sd">            sage: theta = vector([2,2,2,2,2,-5])</span>
<span class="sd">            sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: chi = vector([-1,-1,-1,-1,-1,3])</span>
<span class="sd">            sage: X.point_class(chi,chernClasses=[&#39;x1&#39;,&#39;x2&#39;,&#39;x3&#39;,&#39;x4&#39;,&#39;x5&#39;,&#39;y&#39;,&#39;z&#39;])</span>
<span class="sd">            1/2*z</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">()</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chow_ring</span><span class="p">(</span><span class="n">chi</span><span class="o">=</span><span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">cover</span><span class="p">()</span>  <span class="c1"># The quotient map</span>
        <span class="n">sect</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">lifting_map</span><span class="p">()</span>  <span class="c1"># A choice of a section of pi</span>

        <span class="k">if</span> <span class="n">chi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">my_numerator</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">total_chern_class_universal</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
                <span class="o">**</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">my_denominator</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">total_chern_class_universal</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chi</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
                <span class="o">**</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">quotient</span> <span class="o">=</span> <span class="n">my_numerator</span> <span class="o">/</span> <span class="n">my_denominator</span>

        <span class="k">return</span> <span class="n">pi</span><span class="p">(</span><span class="n">sect</span><span class="p">(</span><span class="n">quotient</span><span class="p">)</span><span class="o">.</span><span class="n">homogeneous_components</span><span class="p">()[</span><span class="n">N</span><span class="p">])</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.degree">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.degree">[docs]</a>
    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the degree of the ample line bundle given by eta.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Need check for ampleness first</span>

        <span class="k">if</span> <span class="n">eta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="o">.</span><span class="n">canonical_stability_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chern_class_line_bundle</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_class</span><span class="p">(</span><span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">c</span><span class="o">**</span><span class="n">N</span> <span class="o">/</span> <span class="n">p</span></div>


<div class="viewcode-block" id="QuiverModuliSpace.todd_class">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliSpace.todd_class">[docs]</a>
    <span class="k">def</span> <span class="nf">todd_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Todd class of `X` is the Todd class of the tangent bundle.</span>

<span class="sd">        For quiver moduli it computes as</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            td(X) =</span>
<span class="sd">            (\prod_{a:i \to j \in Q_1} \prod_{p=1}^{d_j} \prod_{q=1}^{d_i} Q(t_{j,q} -</span>
<span class="sd">            t_{i,p}))/(prod_{i \in Q_0} \prod_{p,q=1}^{d_i} Q(t_{i,q} - t_{i,p}))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">todd_generating_series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            We call the series :math:`Q(t) = t/(1-e^{-t})` the Todd generating series.</span>

<span class="sd">            The function computes the terms of this series up to degree n.&quot;&quot;&quot;</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">bernoulli</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">i</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="o">^</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

        <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Takes an element in a graded ring and discards</span>
<span class="sd">            all homogeneous components of degree &gt; n&quot;&quot;&quot;</span>
            <span class="n">hom</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">homogeneous_components</span><span class="p">()</span>
            <span class="n">keyList</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hom</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">hom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">,</span> <span class="n">keyList</span><span class="p">)])</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>
</div>


    <span class="c1"># TODO: This is maybe too specific.</span>
    <span class="c1"># def diagonal(self, chi=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Computes the class of the diagonal in the Chow ring of X x X where X is the quiver moduli space.&quot;&quot;&quot;</span>
    <span class="c1">#     &quot;&quot;&quot;It is given by the homogeneous component of degree dim X = 1 - &lt;d,d&gt; of the expression c(F)/C(E), where E = bigoplus_{i in Q_0} U_i^vee boxtimes U_i and F = bigoplus_{a in Q_1} U_{s(a)}^vee boxtimes U_{t(a)} = bigoplus_{i,j in Q_0} (U_i^vee boxtimes U_j)^{a_ij}.&quot;&quot;&quot;</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     EXAMPLES</span>

    <span class="c1">#     P^2 as a quiver moduli space:</span>
    <span class="c1">#     sage: from quiver import *</span>
    <span class="c1">#     sage: Q = GeneralizedKroneckerQuiver(3)</span>
    <span class="c1">#     sage: d = vector([1,1])</span>
    <span class="c1">#     sage: theta = vector([1,-1])</span>
    <span class="c1">#     sage: X = QuiverModuliSpace(Q,d,theta,condition=&quot;semistable&quot;)</span>
    <span class="c1">#     sage: X.diagonal()</span>
    <span class="c1">#     x1_1^2 + x1_1*y1_1 + y1_1^2</span>

    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     Q, d, theta = self._Q, self._d, self._theta</span>
    <span class="c1">#     n = Q.number_of_vertices()</span>
    <span class="c1">#     N = self.dimension()</span>
    <span class="c1">#     a = Q.adjacency_matrix()</span>

    <span class="c1">#     di = self._QuiverModuli__tautological_presentation()</span>
    <span class="c1">#     A = di[&quot;Generators&quot;]</span>
    <span class="c1">#     I = di[&quot;Relations&quot;] + A.ideal(chi)</span>

    <span class="c1">#     chernClasses1 = [&#39;x%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernClasses2 = [&#39;y%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernClasses = chernClasses1+chernClasses2</span>

    <span class="c1">#     AxA = PolynomialRing(QQ,chernClasses)</span>
    <span class="c1">#     inclusion1 = A.hom(chernClasses1,AxA)</span>
    <span class="c1">#     inclusion2 = A.hom(chernClasses2,AxA)</span>
    <span class="c1">#     B = QuotientRing(AxA,inclusion1(I) + inclusion2(I),names=chernClasses)</span>

    <span class="c1">#     pi = B.cover() # The quotient map AxA --&gt; B</span>
    <span class="c1">#     sect = B.lifting_map() # A choice of a section of pi</span>

    <span class="c1">#     chernRoots1 = [&#39;t%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernRoots2 = [&#39;u%s_%s&#39;%(i,r) for i in range(1,n+1) for r in range(1,d[i-1]+1)]</span>
    <span class="c1">#     chernRoots = chernRoots1+chernRoots2</span>
    <span class="c1">#     RxR = PolynomialRing(QQ,chernRoots)</span>

    <span class="c1">#     def generatorRxR1(i,r):</span>
    <span class="c1">#         &quot;&quot;&quot;Returns generatorRxR1(i,r) = t{i+1}_{r+1}.&quot;&quot;&quot;</span>
    <span class="c1">#         return RxR.gen(r + sum([d[j] for j in range(i)]))</span>

    <span class="c1">#     def generatorRxR2(i,r):</span>
    <span class="c1">#         &quot;&quot;&quot;Returns generatorRxR2(i,r) = u{i+1}_{r+1}.&quot;&quot;&quot;</span>
    <span class="c1">#         return RxR.gen(sum([d[j] for j in range(n)]) + r + sum([d[j] for j in range(i)]))</span>

    <span class="c1">#     E = SymmetricFunctions(ZZ).e()</span>
    <span class="c1">#     elementarySymmetric1 = []</span>
    <span class="c1">#     elementarySymmetric2 = []</span>
    <span class="c1">#     for i in range(n):</span>
    <span class="c1">#         elementarySymmetric1 = elementarySymmetric1 + [E([k]).expand(d[i], alphabet=[generatorRxR1(i,r) for r in range(d[i])]) for k in range(1,d[i]+1)]</span>
    <span class="c1">#         elementarySymmetric2 = elementarySymmetric2 + [E([k]).expand(d[i], alphabet=[generatorRxR2(i,r) for r in range(d[i])]) for k in range(1,d[i]+1)]</span>
    <span class="c1">#     elementarySymmetric = elementarySymmetric1 + elementarySymmetric2</span>
    <span class="c1">#     &quot;&quot;&quot;Map xi_r to the r-th elementary symmetric function in ti_1,...,ti_{d_i} and yi_r to the same in ui_1,...,ui_{d_i}.&quot;&quot;&quot;</span>
    <span class="c1">#     inclusion = AxA.hom(elementarySymmetric, RxR)</span>

    <span class="c1">#     def total_chern_class_boxproduct(i,j):</span>
    <span class="c1">#         &quot;&quot;&quot;Computes the total Chern class of U_i^vee boxtimes U_j&quot;&quot;&quot;</span>
    <span class="c1">#         c = prod([(1-generatorRxR1(i,r)+generatorRxR2(j,s)) for r in range(d[i]) for s in range(d[j])])</span>
    <span class="c1">#         return pi(inclusion.inverse_image(c))</span>

    <span class="c1">#     numerator = prod([total_chern_class_boxproduct(i,j)**a[i,j] for i in range(n) for j in range(n)])</span>
    <span class="c1">#     denominator = prod([total_chern_class_boxproduct(i,i) for i in range(n)])</span>
    <span class="c1">#     quotient = numerator/denominator</span>

    <span class="c1">#     return pi(sect(quotient).homogeneous_components()[N])</span>


<div class="viewcode-block" id="QuiverModuliStack">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack">[docs]</a>
<span class="k">class</span> <span class="nc">QuiverModuliStack</span><span class="p">(</span><span class="n">QuiverModuli</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span><span class="p">):</span>
        <span class="n">QuiverModuli</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">denom</span><span class="o">=</span><span class="n">denom</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;A &quot;</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span>
            <span class="o">+</span> <span class="s2">&quot; quiver moduli stack with:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;Q = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;d = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;theta = &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QuiverModuliStack.dimension">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.dimension">[docs]</a>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dimension of the moduli stack :math:`[R^{(s)st}/G]`.</span>

<span class="sd">        .. MATH::</span>

<span class="sd">            dim [R^{(s)st}/G] = dim R^{(s)st} - dim G</span>

<span class="sd">        The dimension turns out to be :math:`-\langle d,d\rangle`</span>
<span class="sd">        if the (semi-)stable locus is non-empty&quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;stable&quot;</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_stable_representation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="c1"># TODO is this one correct? we need to check for existence of a stable I think?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span> <span class="ow">and</span> <span class="n">Q</span><span class="o">.</span><span class="n">has_semistable_representation</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">theta</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">Infinity</span></div>


    <span class="k">def</span> <span class="nf">is_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># TODO think about the empty case, should it be smooth?</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="QuiverModuliStack.motive">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.motive">[docs]</a>
    <span class="k">def</span> <span class="nf">motive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gives an expression for the motive of the semistable moduli stack</span>
<span class="sd">        in an appropriate localization of K_0(Var)</span>

<span class="sd">        # TODO more explanation</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Loop quivers::</span>

<span class="sd">            sage: from quiver import *</span>
<span class="sd">            sage: Q, d, theta = LoopQuiver(0), vector([2]), vector([0])</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            1/(L^4 - L^3 - L^2 + L)</span>
<span class="sd">            sage: Q, d, theta = LoopQuiver(1), vector([2]), vector([0])</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            L^3/(L^3 - L^2 - L + 1)</span>

<span class="sd">        The 3-Kronecker quiver::</span>

<span class="sd">            sage: Q, d = GeneralizedKroneckerQuiver(3), vector([2,3])</span>
<span class="sd">            sage: theta = vector([3,-2])</span>
<span class="sd">            sage: X = QuiverModuliStack(Q, d, theta, condition=&quot;semistable&quot;)</span>
<span class="sd">            sage: X.motive()</span>
<span class="sd">            (-L^6 - L^5 - 3*L^4 - 3*L^3 - 3*L^2 - L - 1)/(L - 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Only for semistable.</span>
        <span class="c1"># For stable, we don&#39;t know what the motive is. It&#39;s not pure in general.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_condition</span> <span class="o">==</span> <span class="s2">&quot;semistable&quot;</span>
        <span class="c1"># TODO well: if we have stable == semistable then we can also compute it!</span>

        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

        <span class="c1"># TODO allow some other ring?</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">FunctionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># TODO coercion needs to be checked here</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">():</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">Q</span><span class="o">.</span><span class="n">tits_form</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">prod</span><span class="p">([(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO use proper=True, nonzero=True, or maybe not?</span>
            <span class="c1"># in any case, the next 6 lines are an atrocity</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">all_subdimension_vectors</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">()</span> <span class="ow">and</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">d</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>
            <span class="n">I</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Q</span><span class="o">.</span><span class="n">slope</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">theta</span><span class="p">),</span> <span class="n">I</span><span class="p">))</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">(),</span> <span class="n">d</span><span class="p">]</span>
            <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">Q</span><span class="o">.</span><span class="n">_coerce_dimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>
            <span class="c1"># TODO I believe max(d) on a dict should give the wrong result</span>
            <span class="n">I</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Q</span><span class="o">.</span><span class="n">_deglex_key</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

            <span class="c1"># Now define a matrix T of size NxN whose entry at position (i,j) is</span>
            <span class="c1"># L^&lt;e-f,e&gt;*mot(f-e) if e = I[i] is a subdimension vector of f = I[j]</span>
            <span class="c1"># and 0 otherwise</span>
            <span class="c1"># TODO it&#39;s bad to have a function motive inside a motive method</span>
            <span class="k">def</span> <span class="nf">motive</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">QuiverModuliStack</span><span class="p">(</span>
                    <span class="n">Q</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero_vector</span><span class="p">(),</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;semistable&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">motive</span><span class="p">()</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
                    <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">I</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_subdimension_vector</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
                        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">euler_form</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="o">*</span> <span class="n">motive</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">e</span><span class="p">)</span>

            <span class="c1"># Solve system of linear equations T*x = e_N</span>
            <span class="c1"># and extract entry 0 of the solution x.</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
            <span class="n">y</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">solve_right</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="QuiverModuliStack.chow_ring">
<a class="viewcode-back" href="../../index.html#quiver.QuiverModuliStack.chow_ring">[docs]</a>
    <span class="k">def</span> <span class="nf">chow_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the Chow ring of the quotient stack.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``chernClasses``: list of Strings</span>

<span class="sd">        OUTPUT: ring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup shorthand</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>

        <span class="c1"># TODO there is very similar code earlier</span>
        <span class="k">if</span> <span class="n">chernClasses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chernClasses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;x</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">taut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_QuiverModuli__tautological_presentation</span><span class="p">(</span>
            <span class="n">inRoots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chernClasses</span><span class="o">=</span><span class="n">chernClasses</span>
        <span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rels</span> <span class="o">=</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;ParentRing&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Generators&quot;</span><span class="p">],</span> <span class="n">taut</span><span class="p">[</span><span class="s2">&quot;Relations&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">QuotientRing</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="n">rels</span><span class="p">),</span> <span class="n">names</span><span class="o">=</span><span class="n">chernClasses</span><span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">SmoothModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;How about this: instead of a separate class SmoothModel,</span>
<span class="sd">    we could define a method framed_moduli_space(self,n)</span>
<span class="sd">    inside the class QuiverModuliSpace which returns another quiver moduli space.</span>
<span class="sd">    After all, it is itself a quiver moduli space.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">betti_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="sd">&quot;&quot;&quot;Auxiliary methods:&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">extended_gcd</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the gcd and the Bezout coefficients of a list of integers.&quot;&quot;&quot;</span>
    <span class="c1"># This exists for two integers but there seems to be</span>
    <span class="c1"># no implementation for more than one.</span>
    <span class="c1"># That&#39;s astonishing.</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
        <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_gcd</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=f8c80a57"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>